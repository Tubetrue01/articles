<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/articles/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/articles/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/articles/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/articles/images/logo.svg" color="#222">

<link rel="stylesheet" href="/articles/css/main.css">


<link rel="stylesheet" href="/articles/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tubetrue01.github.io","root":"/articles/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Tubetrue01">
<meta property="og:url" content="https://tubetrue01.github.io/page/6/">
<meta property="og:site_name" content="Tubetrue01">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Tubetrue01">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://tubetrue01.github.io/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Tubetrue01</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/articles/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tubetrue01</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/articles/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/articles/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/articles/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tubetrue01.github.io/2023/03/23/java/Java%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8BSynchronized%E5%AE%9E%E7%8E%B0(%E4%B8%8A)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/articles/img/head.PNG">
      <meta itemprop="name" content="Tubetrue01">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tubetrue01">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/articles/2023/03/23/java/Java%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8BSynchronized%E5%AE%9E%E7%8E%B0(%E4%B8%8A)/" class="post-title-link" itemprop="url">Java 锁机制之 Synchronized 实现（上）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-23 17:01:05" itemprop="dateCreated datePublished" datetime="2023-03-23T17:01:05+08:00">2023-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-05 13:57:57" itemprop="dateModified" datetime="2024-02-05T13:57:57+08:00">2024-02-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote>
<p>为了加快程序的运行效率，我们引入了多线程的概念。但是速度提升的同时引来了共享资源安全性的问题。为了保证多线程下程序的准确性，锁机制就是我们需要掌握的一种手段。本文将介绍的就是 synchronized 的实现原理（以 JDK 8 为基础）。</p>
</blockquote>
<h1 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h1><p>不是所有程序在多线程下就是非安全的，我们判断一个程序是否是多线程安全的需要有下面三个要素：</p>
<ul>
<li><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>如果程序是单线程的，那么它肯定是安全的，因为没有人跟你竞争。</p>
</li>
<li><h4 id="共享资源"><a href="#共享资源" class="headerlink" title="共享资源"></a>共享资源</h4><p>如果资源都是线程独占式的（局部变量），那么也不涉及到安全问题。</p>
</li>
<li><h4 id="非原子性操作"><a href="#非原子性操作" class="headerlink" title="非原子性操作"></a>非原子性操作</h4><p>对资源的操作如果是原子性的，那么也不会存在线程安全性问题。</p>
</li>
</ul>
<p>所以只要同时满足以上三种条件，那么该程序一定是非线程安全性的。</p>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>synchronized 是众多锁中的一种实现方式，我们可以用它对共享资源的操作加锁以实现安全访问。synchronized 存在三种锁类型：</p>
<ul>
<li><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>指代当前对象实例，比如修饰成员方法时。要想访问当前资源必须持有当前对象的锁。</p>
</li>
<li><h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4><p>类对象锁，比如修饰静态方法。由于同一个类可以生成多个对象，那么这些对象独享同一把锁。</p>
</li>
<li><h4 id="object"><a href="#object" class="headerlink" title="object"></a>object</h4><p>对象锁，比如同步代码块，你可以指定任意对象为当前资源上锁。当然了，如果指定的是 this 或者 class 那么作用等同于上述两者。</p>
</li>
</ul>
<h2 id="Java-对象内存布局"><a href="#Java-对象内存布局" class="headerlink" title="Java 对象内存布局"></a>Java 对象内存布局</h2><p>讲解锁实现之前就需要先了解锁的存储，要想了解锁的存储就得知道对象的内存布局：</p>
<img src="/articles/2023/03/23/java/Java%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8BSynchronized%E5%AE%9E%E7%8E%B0(%E4%B8%8A)/01.jpg" class="" width="200">

<p>我们把焦点放到对象头中的 MarkWord 结构，根据操作系统位数的不同，MarkWord 又分为 32 位及 64 位，如下图：</p>
<ul>
<li><h4 id="32-位"><a href="#32-位" class="headerlink" title="32 位"></a>32 位</h4><img src="/articles/2023/03/23/java/Java%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8BSynchronized%E5%AE%9E%E7%8E%B0(%E4%B8%8A)/02.jpg" class="" width="600"></li>
<li><h4 id="64-位"><a href="#64-位" class="headerlink" title="64 位"></a>64 位</h4><img src="/articles/2023/03/23/java/Java%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8BSynchronized%E5%AE%9E%E7%8E%B0(%E4%B8%8A)/03.jpg" class="" width="600"></li>
</ul>
<p>从以上的结构中，我们看出了锁的相关信息了，其中，锁分为无锁、偏向锁、轻量级锁、重量级锁。每个级别它们各自存储的数据结构也有所差异，那也就是说不同的场景对应不同的锁级别。既然我们知道锁是存储在 MarkWord 中的，那么我们就需要看看锁到底是怎么实现的了。</p>
<h2 id="锁的入口"><a href="#锁的入口" class="headerlink" title="锁的入口"></a>锁的入口</h2><blockquote>
<p>我们知道 .java 文件经过编译之后都会变成 .class 的字节码，这些字节码都会交由 JVM 进行解释执行。而对于 synchronized 而言，它存在 monitorenter、monitorexit 两个指令。如果修饰方法时，那么是不存在以上两条指令的，只是对方法加了一个 flag，标识出当前方法是同步方法。那么它们的入口是否一样呢？</p>
</blockquote>
<p>再开始之前，有必要先了解几个基础概念：</p>
<h3 id="markWord"><a href="#markWord" class="headerlink" title="markWord"></a>markWord</h3><blockquote>
<p>C++ 中的 markWord 对象是 markOopDesc，这里我们需要记住锁的几种状态。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk/hotspot/src/share/vm/oops/markOop.hpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">markOopDesc</span>:</span> <span class="keyword">public</span> oopDesc &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">             locked_value             = <span class="number">0</span>, <span class="comment">// 00 轻量级锁</span></span><br><span class="line">             unlocked_value           = <span class="number">1</span>, <span class="comment">// 01 无锁</span></span><br><span class="line">             monitor_value            = <span class="number">2</span>, <span class="comment">// 10 重量级锁</span></span><br><span class="line">             marked_value             = <span class="number">3</span>, <span class="comment">// 11 GC 标记</span></span><br><span class="line">             biased_lock_pattern      = <span class="number">5</span>  <span class="comment">// 101 偏向锁</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BasicLock"><a href="#BasicLock" class="headerlink" title="BasicLock"></a>BasicLock</h3><blockquote>
<p>获取锁时，会将对象头中的 markword 复制一份无锁版保留下来。解锁时，再替换回去，用于还原锁状态。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk/hotspot/src/share/vm/runtime/basicLock.hpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicLock</span> <span class="title">VALUE_OBJ_CLASS_SPEC</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">volatile</span> markOop _displaced_header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BasicObjectLock"><a href="#BasicObjectLock" class="headerlink" title="BasicObjectLock"></a>BasicObjectLock</h3><blockquote>
<p>该对象维护锁与目标对象的关联关系。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk/hotspot/src/share/vm/runtime/basicLock.hpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicLock</span> <span class="title">VALUE_OBJ_CLASS_SPEC</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">volatile</span> markOop _displaced_header; <span class="comment">// 获取锁时，会将对象头中的 markword 复制一份无锁版保留下来。解锁时，再替换回去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicObjectLock</span> <span class="title">VALUE_OBJ_CLASS_SPEC</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  BasicLock _lock;  <span class="comment">// 当前对象拥有的锁记录</span></span><br><span class="line">  oop       _obj;   <span class="comment">// 锁对应的 Java 对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁，顾名思义就是偏向某一方的锁。从 markWord 结构中，我们可以看到当对象处于偏向锁模式时，MarkWord 由线程 ID、Epoch、对象年龄、是否偏向锁、锁标志几个字段组成。</p>
<p>如果一个线程能够将自身的线程 id 保存到 markWord 中，同时将偏向标志打开，就说明该线程成功获取了偏向锁。当线程下次再进来时，跟 markword 中的线程 id 比较，如果一致，说明当前线程已经拥有了锁，那就不需要再次获取锁。</p>
<p>有了以上的基础，我们就开始吧：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp</span></span><br><span class="line"><span class="comment"> * -------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * 代码中使用了大量 CAS 操作，如：oldValue Atomic::cmpxchg_ptr(newVal, address, oldValue)，当 address 中的值与 oldValue 一致时，则将 address 中的值替换为 newVal，并返回原始值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BytecodeInterpreter::run</span><span class="params">(interpreterState istate)</span> </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">      <span class="comment">// 如果是同步方法，对应于 synchronized 修饰的方法（含有 ACC_SYNCHRONIZED）</span></span><br><span class="line">      <span class="keyword">if</span> (METHOD-&gt;<span class="built_in">is_synchronized</span>()) &#123;</span><br><span class="line">          oop rcvr;</span><br><span class="line">          <span class="keyword">if</span> (METHOD-&gt;<span class="built_in">is_static</span>()) &#123;</span><br><span class="line">            <span class="comment">// 获取此方法所属类的常量池进而拿到这个类的 Class 实例</span></span><br><span class="line">            rcvr = METHOD-&gt;<span class="built_in">constants</span>()-&gt;<span class="built_in">pool_holder</span>()-&gt;<span class="built_in">java_mirror</span>();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是非静态方法，那就是当前对象本身了</span></span><br><span class="line">            rcvr = <span class="built_in">LOCALS_OBJECT</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">VERIFY_OOP</span>(rcvr);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 拿到基础对象锁（维护了当前对象与锁的对应关系）</span></span><br><span class="line">          BasicObjectLock* mon = &amp;istate-&gt;<span class="built_in">monitor_base</span>()[<span class="number">-1</span>];</span><br><span class="line">          <span class="comment">// 获取锁对应的 Java 对象</span></span><br><span class="line">          oop monobj = mon-&gt;<span class="built_in">obj</span>();</span><br><span class="line">          <span class="comment">// 锁对应的 Java 对象与当前对象肯定是一致的，否则说明初始化出了问题</span></span><br><span class="line">          <span class="built_in">assert</span>(mon-&gt;<span class="built_in">obj</span>() == rcvr, <span class="string">&quot;method monitor mis-initialized&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">bool</span> success = UseBiasedLocking;</span><br><span class="line">          <span class="comment">// 如果开启了偏向锁功能（默认开启）</span></span><br><span class="line">          <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">            <span class="comment">// 获取当前对象的 markWord</span></span><br><span class="line">            markOop mark = rcvr-&gt;<span class="built_in">mark</span>();</span><br><span class="line">            <span class="comment">// 如果处于偏向状态（锁标记为 101）</span></span><br><span class="line">            <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">              <span class="comment">// 检查偏向锁的拥有者以及纪元的最新状态</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">               * yy 主要由 threadId、epoch、biased、lock 四个字段组成，这几个字段都可能不为 0。</span></span><br><span class="line"><span class="comment">               *</span></span><br><span class="line"><span class="comment">               * 如果 epoch、biased、lock 不为 0，说明对象头中的 mark 与 class 中的 mark 不一致，此时已经不是最新状态了。</span></span><br><span class="line"><span class="comment">               *</span></span><br><span class="line"><span class="comment">               * 如果 threadId 不为 0，那么此时的偏向线程是不确定的，具体需要根据其他字段的状态来选择是重新偏向到当前线程还是撤销偏向</span></span><br><span class="line"><span class="comment">               *</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">              <span class="keyword">intptr_t</span> xx = ((<span class="keyword">intptr_t</span>) THREAD) ^ (<span class="keyword">intptr_t</span>) mark;</span><br><span class="line">              xx = (<span class="keyword">intptr_t</span>) rcvr-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">prototype_header</span>() ^ xx;</span><br><span class="line">              <span class="keyword">intptr_t</span> yy = (xx &amp; ~((<span class="keyword">int</span>) markOopDesc::age_mask_in_place));</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (yy != <span class="number">0</span> ) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果 yy 与偏向锁相与为 0 说明锁的偏向未发生改变</span></span><br><span class="line">                <span class="keyword">if</span> (yy &amp; markOopDesc::biased_lock_mask_in_place == <span class="number">0</span> ) &#123;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 说明 epoch 未发生变化，也就是说当前的 epoch 是有效的，那么接下来的操作才是合法的。因为原型头中的 epoch 只在安全点才会更新</span></span><br><span class="line">                  <span class="keyword">if</span> (yy &amp; markOopDesc::epoch_mask_in_place == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 此时只保留对象的锁偏向状态，年龄、epoch，清除锁的偏向线程（此时，并不知道当前的 owner 是谁）</span></span><br><span class="line">                    <span class="keyword">intptr_t</span> unbiased = (<span class="keyword">intptr_t</span>) mark &amp; (markOopDesc::biased_lock_mask_in_place |</span><br><span class="line">                                                           markOopDesc::age_mask_in_place |</span><br><span class="line">                                                           markOopDesc::epoch_mask_in_place);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 尝试重新偏向到当前线程</span></span><br><span class="line">                    <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span>((<span class="keyword">intptr_t</span>)THREAD | unbiased, (<span class="keyword">intptr_t</span>*) rcvr-&gt;<span class="built_in">mark_addr</span>(), unbiased) != unbiased) &#123;</span><br><span class="line">                      <span class="comment">// 如果偏向失败，那么需要进入 InterpreterRuntime::monitorenter 方法，重新撤销再偏向</span></span><br><span class="line">                      <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">monitorenter</span>(THREAD, mon), handle_exception);</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// epoch 已经过期，那么说明当前的偏向线程已经无效了。此时就以原型头中的值作为 CAS 的比较值进行重新偏向</span></span><br><span class="line">                    try_rebias:</span><br><span class="line">                    xx = (<span class="keyword">intptr_t</span>) rcvr-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">prototype_header</span>() | (<span class="keyword">intptr_t</span>) THREAD;</span><br><span class="line">                    <span class="comment">// 将当前线程替换掉原型头中的偏向线程</span></span><br><span class="line">                    <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span>((<span class="keyword">intptr_t</span>)THREAD | (<span class="keyword">intptr_t</span>) rcvr-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">prototype_header</span>(),</span><br><span class="line">                                            (<span class="keyword">intptr_t</span>*) rcvr-&gt;<span class="built_in">mark_addr</span>(),</span><br><span class="line">                                            (<span class="keyword">intptr_t</span>) mark) != (<span class="keyword">intptr_t</span>) mark) &#123;</span><br><span class="line">                      <span class="comment">// 偏向失败那就执行 InterpreterRuntime::monitorenter</span></span><br><span class="line">                      <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">monitorenter</span>(THREAD, mon), handle_exception);</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 如果锁的偏向状态发生了变化，那就需要撤销偏向。用原型头中的值替换掉对象头中的值，如果失败，说明有其他线程正在竞争该撤销操作，这是没问题的。</span></span><br><span class="line">                  try_revoke_bias:</span><br><span class="line">                  xx = (<span class="keyword">intptr_t</span>) rcvr-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">prototype_header</span>() | (<span class="keyword">intptr_t</span>) THREAD;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span>(rcvr-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">prototype_header</span>(),</span><br><span class="line">                                          (<span class="keyword">intptr_t</span>*) rcvr-&gt;<span class="built_in">mark_addr</span>(),</span><br><span class="line">                                          mark) == mark) &#123;</span><br><span class="line">                    <span class="comment">// (*counters-&gt;revoked_lock_entry_count_addr())++;</span></span><br><span class="line">                  success = <span class="literal">false</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 此时未处于偏向状态</span></span><br><span class="line">              cas_label:</span><br><span class="line">              success = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果未启用偏向锁、未偏向或者偏向失败</span></span><br><span class="line">          <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 获取当前 mark 对象的一个无锁版本</span></span><br><span class="line">            markOop displaced = rcvr-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">set_unlocked</span>();</span><br><span class="line">            <span class="comment">// 更新锁对象中的 markword 记录</span></span><br><span class="line">            mon-&gt;<span class="built_in">lock</span>()-&gt;<span class="built_in">set_displaced_header</span>(displaced);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前对象设置为无锁状态</span></span><br><span class="line">            <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span>(mon, rcvr-&gt;<span class="built_in">mark_addr</span>(), displaced) != displaced) &#123;</span><br><span class="line">              <span class="comment">// 替换失败，说明发生了线程竞争，如果当前线程是锁的拥有者，那就清空基础锁对象中的 markword 记录，毕竟此时的场景是锁重入</span></span><br><span class="line">              <span class="keyword">if</span> (THREAD-&gt;<span class="built_in">is_lock_owned</span>((address) displaced-&gt;<span class="built_in">clear_lock_bits</span>())) &#123;</span><br><span class="line">                mon-&gt;<span class="built_in">lock</span>()-&gt;<span class="built_in">set_displaced_header</span>(<span class="literal">NULL</span>);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 替换失败，并且当前线程并非锁的拥有者，说明当前线程获取锁失败，那么执行 InterpreterRuntime::monitorenter</span></span><br><span class="line">                <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">monitorenter</span>(THREAD, mon), handle_exception);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">      <span class="comment">// 如果是同步代码块，那么就会走这个入口</span></span><br><span class="line">      <span class="built_in">CASE</span>(_monitorenter): &#123;</span><br><span class="line">        <span class="comment">// 获取当前对象</span></span><br><span class="line">        oop lockee = <span class="built_in">STACK_OBJECT</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">CHECK_NULL</span>(lockee);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历当前线程栈，查找空闲的 LockRecord</span></span><br><span class="line">        BasicObjectLock* limit = istate-&gt;<span class="built_in">monitor_base</span>();</span><br><span class="line">        BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;<span class="built_in">stack_base</span>();</span><br><span class="line">        BasicObjectLock* entry = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (most_recent != limit ) &#123;</span><br><span class="line">          <span class="comment">// 如果当前的锁记录没有目标对象，就把它作为候选</span></span><br><span class="line">          <span class="keyword">if</span> (most_recent-&gt;<span class="built_in">obj</span>() == <span class="literal">NULL</span>) entry = most_recent;</span><br><span class="line">          <span class="comment">// 说明已经存在当前对象的锁记录（锁重入）</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (most_recent-&gt;<span class="built_in">obj</span>() == lockee) <span class="keyword">break</span>;</span><br><span class="line">          most_recent++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存在可用的锁记录</span></span><br><span class="line">        <span class="keyword">if</span> (entry != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">// 将锁记录与当前对象绑定</span></span><br><span class="line">          entry-&gt;<span class="built_in">set_obj</span>(lockee);</span><br><span class="line">          <span class="comment">// 将当前对象的 markword 复制成一份无锁版的，displaced mark word</span></span><br><span class="line">          markOop displaced = lockee-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">set_unlocked</span>();</span><br><span class="line">          <span class="comment">// 将 displaced mark word 设置到当前锁记录中</span></span><br><span class="line">          entry-&gt;<span class="built_in">lock</span>()-&gt;<span class="built_in">set_displaced_header</span>(displaced);</span><br><span class="line">          <span class="comment">// 更新对象中的锁记录信息</span></span><br><span class="line">          <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span>(entry, lockee-&gt;<span class="built_in">mark_addr</span>(), displaced) != displaced) &#123;</span><br><span class="line">            <span class="comment">// 如果更新失败，说明其他线程参与了竞争，那就判断当前线程是否是锁记录的持有者</span></span><br><span class="line">            <span class="keyword">if</span> (THREAD-&gt;<span class="built_in">is_lock_owned</span>((address) displaced-&gt;<span class="built_in">clear_lock_bits</span>())) &#123;</span><br><span class="line">              <span class="comment">// 如果是，说明发生了锁重入，那么将当前栈中的 markWord 至为 null</span></span><br><span class="line">              entry-&gt;<span class="built_in">lock</span>()-&gt;<span class="built_in">set_displaced_header</span>(<span class="literal">NULL</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 说明当前线程非锁的持有线程，并且获取锁失败，那就需要执行 monitorenter</span></span><br><span class="line">              <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">monitorenter</span>(THREAD, entry), handle_exception);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">UPDATE_PC_AND_TOS_AND_CONTINUE</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果未找到可用的锁记录，就需要告诉系统创建一个新的</span></span><br><span class="line">          istate-&gt;<span class="built_in">set_msg</span>(more_monitors);</span><br><span class="line">          <span class="built_in">UPDATE_PC_AND_RETURN</span>(<span class="number">0</span>); <span class="comment">// Re-execute</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 退出同步代码块</span></span><br><span class="line">      <span class="built_in">CASE</span>(_monitorexit): &#123;</span><br><span class="line">        <span class="comment">// 获取当前对象</span></span><br><span class="line">        oop lockee = <span class="built_in">STACK_OBJECT</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">CHECK_NULL</span>(lockee);</span><br><span class="line"></span><br><span class="line">        BasicObjectLock* limit = istate-&gt;<span class="built_in">monitor_base</span>();</span><br><span class="line">        BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;<span class="built_in">stack_base</span>();</span><br><span class="line">        <span class="comment">// 遍历当前线程拥有的 Lock Record</span></span><br><span class="line">        <span class="keyword">while</span> (most_recent != limit ) &#123;</span><br><span class="line">          <span class="comment">// 如果找到当前线程对应的锁记录</span></span><br><span class="line">          <span class="keyword">if</span> ((most_recent)-&gt;<span class="built_in">obj</span>() == lockee) &#123;</span><br><span class="line">            <span class="comment">// 拿到锁</span></span><br><span class="line">            BasicLock* lock = most_recent-&gt;<span class="built_in">lock</span>();</span><br><span class="line">            <span class="comment">// 拿到锁记录中的 displaced mark word</span></span><br><span class="line">            markOop header = lock-&gt;<span class="built_in">displaced_header</span>();</span><br><span class="line">            <span class="comment">// 取消锁与对象的绑定，释放 Lock Record</span></span><br><span class="line">            most_recent-&gt;<span class="built_in">set_obj</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (header != <span class="literal">NULL</span>) &#123;</span><br><span class="line">              <span class="comment">// 将 displaced mark word 替换回原有对象（displaced mark word 是先前对象 mark word 的一个无锁版本），表示当前对象处于无锁状态</span></span><br><span class="line">              <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span>(header, lockee-&gt;<span class="built_in">mark_addr</span>(), lock) != lock) &#123;</span><br><span class="line">                <span class="comment">// 如果替换失败，说明发生了竞争，需要重新绑定然后交由 monitorexit 来处理</span></span><br><span class="line">                most_recent-&gt;<span class="built_in">set_obj</span>(lockee);</span><br><span class="line">                <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">monitorexit</span>(THREAD, most_recent), handle_exception);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">UPDATE_PC_AND_TOS_AND_CONTINUE</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          most_recent++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Need to throw illegal monitor state exception</span></span><br><span class="line">        <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">throw_illegal_monitor_state_exception</span>(THREAD), handle_exception);</span><br><span class="line">        <span class="built_in">ShouldNotReachHere</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上就是同步代码块、同步方法的入口点。程序进入 <code>InterpreterRuntime::monitorenter</code> 方法的条件就是当前线程获取偏向锁失败（注意：此时就已经存在 LockRecord 了，大家可以比较一下偏向锁跟轻量级锁中，LockRecord 的作用是否一致）。我们把以上逻辑以图例的形式表现出来：</p>
<ul>
<li><p>同步方法</p>
<img src="/articles/2023/03/23/java/Java%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8BSynchronized%E5%AE%9E%E7%8E%B0(%E4%B8%8A)/04.jpg" class="" width="600"></li>
<li><p>同步代码块</p>
<img src="/articles/2023/03/23/java/Java%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8BSynchronized%E5%AE%9E%E7%8E%B0(%E4%B8%8A)/05.jpg" class="" width="600"></li>
<li><p>同步代码块退出指令</p>
<img src="/articles/2023/03/23/java/Java%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8BSynchronized%E5%AE%9E%E7%8E%B0(%E4%B8%8A)/06.jpg" class="" width="400"></li>
</ul>
<p>如果获取偏向锁失败的话，就需要执行 <code>InterpreterRuntime::monitorenter</code> 方法：</p>
<h4 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h4><blockquote>
<p>InterpreterRuntime::monitorenter 方法是 monitorenter 指令的入口，该方法通过判断是否启用偏向锁来选择快速进入还是慢进入。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IRT_ENTRY_NO_ASYNC 为宏定义(jdk/hotspot/src/share/vm/runtime/interfaceSupport.hpp)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * #define IRT_ENTRY_NO_ASYNC(result_type, header)      \</span></span><br><span class="line"><span class="comment"> *   result_type header &#123;                               \</span></span><br><span class="line"><span class="comment"> *     ThreadInVMfromJavaNoAsyncException __tiv(thread);\</span></span><br><span class="line"><span class="comment"> *     VM_ENTRY_BASE(result_type, header, thread)       \</span></span><br><span class="line"><span class="comment"> *     debug_only(VMEntryWrapper __vew;)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * #define IRT_END &#125;</span></span><br><span class="line"><span class="comment"> * -------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * 参数：JavaThread 为 Java 线程对象的封装</span></span><br><span class="line"><span class="comment"> *      BasicObjectLock 为基础锁对象，维护了锁与 Java 对象的关联关系</span></span><br><span class="line"><span class="comment"> * -------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * Handle 对象维护了描述 Java 对象的 oop 以及 Java 对象类对象的 klass</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">IRT_ENTRY_NO_ASYNC</span>(<span class="keyword">void</span>, InterpreterRuntime::<span class="built_in">monitorenter</span>(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;<span class="built_in">last_frame</span>().<span class="built_in">interpreter_frame_verify_monitor</span>(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 记录统计信息</span></span><br><span class="line">  <span class="keyword">if</span> (PrintBiasedLockingStatistics) &#123;</span><br><span class="line">    <span class="comment">// 递增慢进入数量</span></span><br><span class="line">    Atomic::<span class="built_in">inc</span>(BiasedLocking::<span class="built_in">slow_path_entry_count_addr</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将对象封装成句柄，后续的对象访问通过句柄实现</span></span><br><span class="line">  <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj())</span></span>;</span><br><span class="line">  <span class="built_in">assert</span>(Universe::<span class="built_in">heap</span>()-&gt;<span class="built_in">is_in_reserved_or_null</span>(<span class="built_in">h_obj</span>()),</span><br><span class="line">         <span class="string">&quot;must be NULL or an object&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果启用偏向锁（默认开启），那么可以尝试快速进入，避免锁膨胀</span></span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">    ObjectSynchronizer::<span class="built_in">fast_enter</span>(h_obj, elem-&gt;<span class="built_in">lock</span>(), <span class="literal">true</span>, CHECK);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ObjectSynchronizer::<span class="built_in">slow_enter</span>(h_obj, elem-&gt;<span class="built_in">lock</span>(), CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(Universe::<span class="built_in">heap</span>()-&gt;<span class="built_in">is_in_reserved_or_null</span>(elem-&gt;<span class="built_in">obj</span>()),</span><br><span class="line">         <span class="string">&quot;must be NULL or an object&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;<span class="built_in">last_frame</span>().<span class="built_in">interpreter_frame_verify_monitor</span>(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">IRT_END</span><br></pre></td></tr></table></figure>

<h4 id="fast-enter"><a href="#fast-enter" class="headerlink" title="fast_enter"></a>fast_enter</h4><blockquote>
<p>jdk/hotspot/src/share/vm/runtime/synchronizer.cpp</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::fast_enter</span><span class="params">(Handle obj, BasicLock* lock, <span class="keyword">bool</span> attempt_rebias, TRAPS)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 判断是否启用偏向锁，如果未启用，还是得走慢进入逻辑</span></span><br><span class="line"> <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// 判断当前是否处于安全点</span></span><br><span class="line">    <span class="keyword">if</span> (!SafepointSynchronize::<span class="built_in">is_at_safepoint</span>()) &#123;</span><br><span class="line">      <span class="comment">// 尝试获取偏向锁</span></span><br><span class="line">      BiasedLocking::Condition cond = BiasedLocking::<span class="built_in">revoke_and_rebias</span>(obj, attempt_rebias, THREAD);</span><br><span class="line">      <span class="comment">// 如果当前状态为撤销与重偏向，那么返回</span></span><br><span class="line">      <span class="keyword">if</span> (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果在安全点，那么需要撤销偏向</span></span><br><span class="line">      <span class="built_in">assert</span>(!attempt_rebias, <span class="string">&quot;can not rebias toward VM thread&quot;</span>);</span><br><span class="line">      <span class="comment">// 撤销偏向</span></span><br><span class="line">      BiasedLocking::<span class="built_in">revoke_at_safepoint</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 偏向锁获取失败，那么到了这里锁的偏向状态应该已经撤销，然后开始获取轻量级锁</span></span><br><span class="line">    <span class="built_in">assert</span>(!obj-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;biases should be revoked by now&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 获取轻量级锁</span></span><br><span class="line"> <span class="built_in">slow_enter</span> (obj, lock, THREAD) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------辅助方法--------------------------//</span></span><br><span class="line"><span class="comment">// jdk/hotspot/src/share/vm/runtime/safepoint.hpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafepointSynchronize</span> :</span> AllStatic &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">SynchronizeState</span> &#123;</span></span><br><span class="line">      _synchronized = <span class="number">2</span>   <span class="comment">// 所有的 Java 线程全部停在安全点，只有 jvm 线程在运行</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 判断当前是否处于安全点</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">is_at_safepoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> _state == _synchronized;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>revoke_and_rebias</p>
<blockquote>
<p>jdk/hotspot/src/share/vm/runtime/biasedLocking.cpp</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Handle 内部维护了 oop 对象，同时 Handle 重写了 -&gt; 操作符，所以</span></span><br><span class="line"><span class="comment">   * obj-&gt;mark()、obj-&gt;klass() 其实调用的是 oop（实际上是 oopDesc ） 的对应方法。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">BiasedLocking::Condition <span class="title">BiasedLocking::revoke_and_rebias</span><span class="params">(Handle obj, <span class="keyword">bool</span> attempt_rebias, TRAPS)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只有在非安全点的时候才能继续执行</span></span><br><span class="line">  <span class="built_in">assert</span>(!SafepointSynchronize::<span class="built_in">is_at_safepoint</span>(), <span class="string">&quot;must not be called while at safepoint&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拿到 markWord 对象</span></span><br><span class="line">  markOop mark = obj-&gt;<span class="built_in">mark</span>();</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 匿名偏向就是当前 markWord 中已打开偏向标志位，但是 threadId 为空</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 如果处于匿名偏向状态，但是不允许重新偏向，那么就需要撤销偏向</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">is_biased_anonymously</span>() &amp;&amp; !attempt_rebias) &#123;</span><br><span class="line"></span><br><span class="line">    markOop biased_value       = mark;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个相同年龄的非偏向对象</span></span><br><span class="line">    markOop unbiased_prototype = markOopDesc::<span class="built_in">prototype</span>()-&gt;<span class="built_in">set_age</span>(mark-&gt;<span class="built_in">age</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 CAS 操作将 Java 对象中的偏向状态设置成未偏向，以此达到撤销偏向的目的</span></span><br><span class="line">    markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(unbiased_prototype, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明 CAS 成功（如果成功了，说明当前没有线程参与竞争）</span></span><br><span class="line">    <span class="keyword">if</span> (res_mark == biased_value) &#123;</span><br><span class="line">      <span class="comment">// 返回已撤销</span></span><br><span class="line">      <span class="keyword">return</span> BIAS_REVOKED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">     <span class="comment">// 当前处于偏向模式</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">    <span class="comment">// 获取 Java 对象的类对象</span></span><br><span class="line">    Klass* k = obj-&gt;<span class="built_in">klass</span>();</span><br><span class="line">    <span class="comment">// 拿到类对象中的 markWord</span></span><br><span class="line">    markOop prototype_header = k-&gt;<span class="built_in">prototype_header</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果此时类的状态为未偏向</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!prototype_header-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">      markOop biased_value       = mark;</span><br><span class="line">      <span class="comment">// 替换</span></span><br><span class="line">      markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(prototype_header, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line">      <span class="built_in">assert</span>(!(*(obj-&gt;<span class="built_in">mark_addr</span>()))-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;even if we raced, should still be revoked&quot;</span>);</span><br><span class="line">      <span class="comment">// 撤销成功</span></span><br><span class="line">      <span class="keyword">return</span> BIAS_REVOKED;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * 当前偏向时间戳过期的话说明该对象已经偏向失效了。根据具体需求即 attempt_rebias 来决定是重新偏向还是撤销偏向</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (prototype_header-&gt;<span class="built_in">bias_epoch</span>() != mark-&gt;<span class="built_in">bias_epoch</span>()) &#123;</span><br><span class="line">     <span class="comment">// 如果需要重新偏向</span></span><br><span class="line">     <span class="keyword">if</span> (attempt_rebias) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(THREAD-&gt;<span class="built_in">is_Java_thread</span>(), <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        markOop biased_value       = mark;</span><br><span class="line">        <span class="comment">// 既然是重新偏向，就需要将当前线程记录下来，同时还有对象的年龄及偏向时间</span></span><br><span class="line">        markOop rebiased_prototype = markOopDesc::<span class="built_in">encode</span>((JavaThread*) THREAD, mark-&gt;<span class="built_in">age</span>(), prototype_header-&gt;<span class="built_in">bias_epoch</span>());</span><br><span class="line">        <span class="comment">// CAS 更新</span></span><br><span class="line">        markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(rebiased_prototype, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (res_mark == biased_value) &#123;</span><br><span class="line">          <span class="comment">// 撤销成功并且已重新偏向当前线程</span></span><br><span class="line">          <span class="keyword">return</span> BIAS_REVOKED_AND_REBIASED;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果只是单纯的撤销偏向</span></span><br><span class="line">        markOop biased_value       = mark;</span><br><span class="line">        <span class="comment">// 那就生成一个相同年龄非偏向的新对象头</span></span><br><span class="line">        markOop unbiased_prototype = markOopDesc::<span class="built_in">prototype</span>()-&gt;<span class="built_in">set_age</span>(mark-&gt;<span class="built_in">age</span>());</span><br><span class="line">        markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(unbiased_prototype, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line">        <span class="keyword">if</span> (res_mark == biased_value) &#123;</span><br><span class="line">          <span class="comment">// 撤销偏向成功</span></span><br><span class="line">          <span class="keyword">return</span> BIAS_REVOKED;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果对象头为不可偏向、CAS 更新失败就会进行启发式更新，该方法会对撤销偏向锁计数进行递增（注意这里重写的括号操作符 obj()）</span></span><br><span class="line">  HeuristicsResult heuristics = <span class="built_in">update_heuristics</span>(<span class="built_in">obj</span>(), attempt_rebias);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不可偏向</span></span><br><span class="line">  <span class="keyword">if</span> (heuristics == HR_NOT_BIASED) &#123;</span><br><span class="line">    <span class="keyword">return</span> NOT_BIASED;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 未到批处理阈值</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (heuristics == HR_SINGLE_REVOKE) &#123;</span><br><span class="line">    <span class="comment">// 获取类对象</span></span><br><span class="line">    Klass *k = obj-&gt;<span class="built_in">klass</span>();</span><br><span class="line">    <span class="comment">// 取类对象中的头信息</span></span><br><span class="line">    markOop prototype_header = k-&gt;<span class="built_in">prototype_header</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前线程就是偏向锁的所有者，同时偏向还有效，那就由当前线程完成撤销</span></span><br><span class="line">    <span class="keyword">if</span> (mark-&gt;<span class="built_in">biased_locker</span>() == THREAD &amp;&amp;</span><br><span class="line">        prototype_header-&gt;<span class="built_in">bias_epoch</span>() == mark-&gt;<span class="built_in">bias_epoch</span>()) &#123;</span><br><span class="line">      ResourceMark rm;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 信息记录</span></span><br><span class="line">      <span class="keyword">if</span> (TraceBiasedLocking) &#123;</span><br><span class="line">        tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;Revoking bias by walking my own stack:&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注意 obj() 返回的是内部的 oop 对象，也就是当前对应的 Java 对象</span></span><br><span class="line">      BiasedLocking::Condition cond = <span class="built_in">revoke_bias</span>(<span class="built_in">obj</span>(), <span class="literal">false</span>, <span class="literal">false</span>, (JavaThread*) THREAD);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 因为已经撤销了，那就把当前线程拥有的 monitor 对象置 NULL</span></span><br><span class="line">      ((JavaThread*) THREAD)-&gt;<span class="built_in">set_cached_monitor_info</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">assert</span>(cond == BIAS_REVOKED, <span class="string">&quot;why not?&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> cond;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果当前线程不是偏向锁偏向的线程，那么就由虚拟机线程处理了。</span></span><br><span class="line">      VM_RevokeBias <span class="built_in">revoke</span>(&amp;obj, (JavaThread*) THREAD);</span><br><span class="line">      VMThread::<span class="built_in">execute</span>(&amp;revoke);</span><br><span class="line">      <span class="keyword">return</span> revoke.<span class="built_in">status_code</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果既不是 HR_BULK_REVOKE 也不是 HR_BULK_REBIAS，那不就有问题了？</span></span><br><span class="line">  <span class="built_in">assert</span>((heuristics == HR_BULK_REVOKE) ||</span><br><span class="line">         (heuristics == HR_BULK_REBIAS), <span class="string">&quot;?&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只能交由虚拟机线程完成批处理了）</span></span><br><span class="line">  <span class="function">VM_BulkRevokeBias <span class="title">bulk_revoke</span><span class="params">(&amp;obj, (JavaThread*) THREAD,</span></span></span><br><span class="line"><span class="params"><span class="function">                                (heuristics == HR_BULK_REBIAS),</span></span></span><br><span class="line"><span class="params"><span class="function">                                attempt_rebias)</span></span>;</span><br><span class="line">  VMThread::<span class="built_in">execute</span>(&amp;bulk_revoke);</span><br><span class="line">  <span class="keyword">return</span> bulk_revoke.<span class="built_in">status_code</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JVM 内部为每个类维护了一个偏向锁 revoke 计数器，记录每个对象的撤销次数。当这个计数达到指定阈值（BiasedLockingBulkRebiasThreshold, 20）时，JVM 认为该类的偏向锁有问题了，需要重新偏向。批量操作的含义就是将该类的所有对象进行重偏向（bulk rebias）。</p>
</li>
</ul>
<p>当 bulk rebias 时，会对这个类的 epoch 加一，后期为该类分配对象时都以该值为基础，同时还要对当前已获得偏向锁的 epoch 加一，并将这些锁记录保存在方法栈里。</p>
<p>判断一个对象是否是获得偏向锁的条件是：markWord 后三位为 101，线程 ID 字段等于当前线程，epoch 与该对象所属类的 epoch 相同。如果 epoch 不一样，说明进行了重偏向，只不过没有更新到该对象中，所以也是无效的，即使线程 ID 一样。</p>
<p>如果该类的 revoke 计数继续增加达到另一个阈值（BiasedLockingBulkRevokeThreshold, 40），那就说明该类不再适合偏向，需要进行 bulk revoke 了。如以下代码：</p>
<ul>
<li><p>update_heuristics</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> HeuristicsResult <span class="title">update_heuristics</span><span class="params">(oop o, <span class="keyword">bool</span> allow_rebias)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取 markWord 对象</span></span><br><span class="line">  markOop mark = o-&gt;<span class="built_in">mark</span>();</span><br><span class="line">  <span class="comment">// 未处于偏移模式</span></span><br><span class="line">  <span class="keyword">if</span> (!mark-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> HR_NOT_BIASED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取类对象</span></span><br><span class="line">  Klass* k = o-&gt;<span class="built_in">klass</span>();</span><br><span class="line">  jlong cur_time = os::<span class="built_in">javaTimeMillis</span>();</span><br><span class="line">  <span class="comment">// 最近一次批量撤销偏向锁的时间</span></span><br><span class="line">  jlong last_bulk_revocation_time = k-&gt;<span class="built_in">last_biased_lock_bulk_revocation_time</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取撤销次数</span></span><br><span class="line">  <span class="keyword">int</span> revocation_count = k-&gt;<span class="built_in">biased_lock_revocation_count</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * BiasedLockingBulkRebiasThreshold = 20</span></span><br><span class="line"><span class="comment">   * BiasedLockingBulkRevokeThreshold = 40</span></span><br><span class="line"><span class="comment">   * BiasedLockingDecayTime = 25000ms</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> ((revocation_count &gt;= BiasedLockingBulkRebiasThreshold) &amp;&amp;</span><br><span class="line">      (revocation_count &lt;  BiasedLockingBulkRevokeThreshold) &amp;&amp;</span><br><span class="line">      (last_bulk_revocation_time != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">      (cur_time - last_bulk_revocation_time &gt;= BiasedLockingDecayTime)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置撤销次数</span></span><br><span class="line">    k-&gt;<span class="built_in">set_biased_lock_revocation_count</span>(<span class="number">0</span>);</span><br><span class="line">    revocation_count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果小于撤销阈值，那么递增</span></span><br><span class="line">  <span class="keyword">if</span> (revocation_count &lt;= BiasedLockingBulkRevokeThreshold) &#123;</span><br><span class="line">    revocation_count = k-&gt;<span class="built_in">atomic_incr_biased_lock_revocation_count</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 满足撤销阈值，那么需要批量撤销</span></span><br><span class="line">  <span class="keyword">if</span> (revocation_count == BiasedLockingBulkRevokeThreshold) &#123;</span><br><span class="line">    <span class="keyword">return</span> HR_BULK_REVOKE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 满足重偏向阈值，需要批量重偏向</span></span><br><span class="line">  <span class="keyword">if</span> (revocation_count == BiasedLockingBulkRebiasThreshold) &#123;</span><br><span class="line">    <span class="keyword">return</span> HR_BULK_REBIAS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只是单纯撤销就行了</span></span><br><span class="line">  <span class="keyword">return</span> HR_SINGLE_REVOKE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前处于非安全点并且撤销重偏向成功的话，那么就说明拿到了锁无需进行锁膨胀。但是，如果当前就在安全点，那么就需要执行安全点的撤销逻辑了。</p>
</li>
<li><p>revoke_at_safepoint</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BiasedLocking::revoke_at_safepoint</span><span class="params">(GrowableArray&lt;Handle&gt;* objs)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 必须处于安全点</span></span><br><span class="line">  <span class="built_in">assert</span>(SafepointSynchronize::<span class="built_in">is_at_safepoint</span>(), <span class="string">&quot;must only be called while at safepoint&quot;</span>);</span><br><span class="line">  <span class="keyword">int</span> len = objs-&gt;<span class="built_in">length</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    oop obj = (objs-&gt;<span class="built_in">at</span>(i))();</span><br><span class="line">    <span class="comment">// 对撤销操作进行计数，并获取当前撤销类型</span></span><br><span class="line">    HeuristicsResult heuristics = <span class="built_in">update_heuristics</span>(obj, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (heuristics == HR_SINGLE_REVOKE) &#123;</span><br><span class="line">      <span class="comment">// 撤销偏向</span></span><br><span class="line">      <span class="built_in">revoke_bias</span>(obj, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((heuristics == HR_BULK_REBIAS) ||</span><br><span class="line">               (heuristics == HR_BULK_REVOKE)) &#123;</span><br><span class="line">      <span class="comment">// 批量撤销</span></span><br><span class="line">      <span class="built_in">bulk_revoke_or_rebias_at_safepoint</span>(obj, (heuristics == HR_BULK_REBIAS), <span class="literal">false</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历所有线程，逐步清除缓存的 monitor 信息</span></span><br><span class="line">  <span class="built_in">clean_up_cached_monitor_info</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原本计划是用一篇文章将 synchronized 这块核心知识点讲完，但是既然写了，那就从头至尾详详细细的梳理一遍。当然，换来的就是文章篇幅过长，既然如此，那干脆将 synchronized 这块内容分为两篇吧。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/articles/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/articles/">1</a><span class="space">&hellip;</span><a class="page-number" href="/articles/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/articles/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/articles/page/67/">67</a><a class="extend next" rel="next" href="/articles/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Tubetrue01"
      src="/articles/img/head.PNG">
  <p class="site-author-name" itemprop="name">Tubetrue01</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/articles/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/articles/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Tubetrue01" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Tubetrue01" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/articles/Tubetrue01@gmail.com" title="E-Mail → Tubetrue01@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tubetrue01</span>
</div>



        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/articles/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script>
  <script src="/articles/lib/velocity/velocity.min.js"></script>
  <script src="/articles/lib/velocity/velocity.ui.min.js"></script>

<script src="/articles/js/utils.js"></script>

<script src="/articles/js/motion.js"></script>


<script src="/articles/js/schemes/pisces.js"></script>


<script src="/articles/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  


    </div>
</body>
</html>
