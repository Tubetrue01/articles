<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/articles/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/articles/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/articles/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/articles/images/logo.svg" color="#222">

<link rel="stylesheet" href="/articles/css/main.css">


<link rel="stylesheet" href="/articles/libs/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tubetrue01.github.io","root":"/articles/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Tubetrue01">
<meta property="og:url" content="https://tubetrue01.github.io/page/62/">
<meta property="og:site_name" content="Tubetrue01">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Tubetrue01">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://tubetrue01.github.io/page/62/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Tubetrue01</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/articles/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tubetrue01</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/articles/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/articles/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/articles/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://www.jianshu.com/u/46af180aa88f" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tubetrue01.github.io/2020/12/18/c_reprint/C%E8%BD%AC%E8%BD%BD%E7%B3%BB%E5%88%97(%E4%B8%80)%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/articles/img/head.PNG">
      <meta itemprop="name" content="Tubetrue01">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tubetrue01">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/articles/2020/12/18/c_reprint/C%E8%BD%AC%E8%BD%BD%E7%B3%BB%E5%88%97(%E4%B8%80)%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">C 转载系列（一）指针详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-18 09:34:28" itemprop="dateCreated datePublished" datetime="2020-12-18T09:34:28+08:00">2020-12-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-25 09:58:03" itemprop="dateModified" datetime="2021-08-25T09:58:03+08:00">2021-08-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote>
<p>文章写的很精彩（也很长，所以尽量做好排版，起码看起来不那么累），是我读过的对指针讲解最详细的文章了，所以我把它引过来，然后对相关内容进行了补充与修正，以加深对指针的理解与使用。好了，废话不多说，我们进入正题。</p>
</blockquote>
<h1 id="一、-细说指针"><a href="#一、-细说指针" class="headerlink" title="一、 细说指针"></a>一、 细说指针</h1><p>指针是一个特殊的变量，它里面存储的数值被解释成内存里的一个地址。要搞清一个指针需要搞清指针的四个方面内容：</p>
<ul>
<li><strong>指针的类型</strong></li>
<li><strong>指针所指向的类型</strong></li>
<li><strong>指针的值或者叫指针所指向的内存区</strong></li>
<li><strong>指针本身所占据的内存区</strong></li>
</ul>
<p>先声明几个指针放着做例子，<strong>例一：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) <span class="keyword">int</span> *ptr;</span><br><span class="line">(<span class="number">2</span>) <span class="keyword">char</span> *ptr;</span><br><span class="line">(<span class="number">3</span>) <span class="keyword">int</span> **ptr;</span><br><span class="line">(<span class="number">4</span>) <span class="keyword">int</span> (*ptr)[<span class="number">3</span>];</span><br><span class="line">(<span class="number">5</span>) <span class="keyword">int</span> *(*ptr)[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<h2 id="1-指针的类型"><a href="#1-指针的类型" class="headerlink" title="1. 指针的类型"></a>1. 指针的类型</h2><blockquote>
<p>从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。</p>
</blockquote>
<ul>
<li><strong>int *ptr</strong><br>指针的类型是 int *</li>
<li><strong>char *ptr</strong><br>指针的类型是 char *</li>
<li><strong>int **ptr</strong><br>指针的类型是 int **</li>
<li><strong>int (*ptr)[3]</strong><br>指针的类型是 int (*)[3]</li>
<li><strong>int *(*ptr)[4]</strong><br>指针的类型是 int *(*)[4]<h2 id="2-指针所指向的类型"><a href="#2-指针所指向的类型" class="headerlink" title="2. 指针所指向的类型"></a>2. 指针所指向的类型</h2><blockquote>
<p>当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符 <strong>*</strong> 去掉，剩下的就是指针所指向的类型。</p>
</blockquote>
</li>
<li><strong>int *ptr</strong><br>指针所指向的类型是 int</li>
<li><strong>char *ptr</strong><br>指针所指向的的类型是 char</li>
<li><strong>int **ptr</strong><br>指针所指向的的类型是 int *</li>
<li><strong>int (*ptr)[3]</strong><br>指针所指向的的类型是 int ()[3]</li>
<li><strong>int *(*ptr)[4]</strong><br>指针所指向的的类型是 int *()[4]</li>
</ul>
<p><strong>在指针的算术运算中，指针所指向的类型有很大的作用</strong>。<br>指针的类型（即指针本身的类型）和指针所指向的类型是两个概念。当你对 C  越来越熟悉时，你会发现，把与指针搅和在一起的 “类型” 这个概念分成 “指针的类型” 和 “指针所指向的类型” 两个概念，是精通指针的关键点之一。我看了不少书，发现有些写得差的书中，就把指针的这两个概念搅在一起了，所以看起书来前后矛盾，越看越糊涂。</p>
<h2 id="3-指针的值（或者叫指针所指向的内存区或地址）"><a href="#3-指针的值（或者叫指针所指向的内存区或地址）" class="headerlink" title="3. 指针的值（或者叫指针所指向的内存区或地址）"></a>3. 指针的值（或者叫指针所指向的内存区或地址）</h2><blockquote>
<p>指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在 32 位程序里，所有类型的指针的值都是一个 32 位整数，因为 32 位程序里内存地址全都是 32 位长。指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为 sizeof(指针所指向的类型) 的一片内存区。以后，我们说一个指针的值是 XX，就相当于说该指针指向了以 XX 为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。</p>
</blockquote>
<p><strong>以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？（重点注意）</strong></p>
<h1 id="4-指针本身所占据的内存区"><a href="#4-指针本身所占据的内存区" class="headerlink" title="4. 指针本身所占据的内存区"></a>4. 指针本身所占据的内存区</h1><blockquote>
<p>指针本身占了多大的内存？你只要用函数 sizeof(指针的类型) 测一下就知道了。在 32 位平台里，指针本身占据了 4 个字节的长度。指针本身占据的内存这个概念在判断一个指针表达式（后面会解释）是否是左值时很有用。</p>
</blockquote>
<h1 id="二、-指针的算术运算"><a href="#二、-指针的算术运算" class="headerlink" title="二、 指针的算术运算"></a>二、 指针的算术运算</h1><p>指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的，以单元为单位。例如：<br><strong>例二：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> *ptr = (<span class="keyword">int</span> *) a; <span class="comment">/* 强制类型转换并不会改变 a 的类型 */</span></span><br><span class="line">ptr++;</span><br></pre></td></tr></table></figure>
<p>在上例中，指针 ptr 的类型是 int *，它指向的类型是 int，它被初始化为指向整型变量 a。接下来的第 3 句中，指针 ptr 被加了1，编译器是这样处理的：它把指针 ptr 的值加上了 sizeof(int)，在 32 位程序中，是被加上了 4，因为在 32 位程序中，int 占 4 个字节。由于地址是用字节做单位的，故 ptr 所指向的地址由原来的变量 a 的地址向高地址方向增加了 4 个字节。由于 char 类型的长度是一个字节，所以，原来 ptr 是指向数组 a 的第 0 号单元开始的四个字节，此时指向了数组 a 中从第 4 号单元开始的四个字节。我们可以用一个指针和一个循环来遍历一个数组，看例子：<br><strong>例三：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *ptr = <span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    (*ptr)++;</span><br><span class="line">    ptr++；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子将整型数组中各个单元的值加 1。由于每次循环都将指针 ptr 加1 个单元，所以每次循环都能访问数组的下一个单元。<br>再看例子：<br><strong>例四：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">20</span>] = <span class="string">&quot;You_are_a_girl&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> *ptr = (<span class="keyword">int</span> *)a;</span><br><span class="line">ptr += <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，ptr 被加上了 5，编译器是这样处理的：将指针 ptr 的值加上 5 乘 sizeof(int)，在 32 位程序中就是加上了 5 乘 4 = 20。由于地址的单位是字节，故现在的 ptr 所指向的地址比起加 5 后的 ptr 所指向的地址来说，向高地址方向移动了 20 个字节。<br>在这个例子中，没加 5 前的 ptr 指向数组 a 的第 0 号单元开始的四个字节，加 5 后，ptr 已经指向了数组 a 的合法范围之外了。虽然这种情况在应用上会出问题，但在语法上却是可以的。这也体现出了指针的灵活性。如果上例中，ptr 是被减去 5，那么处理过程大同小异，只不过 ptr 的值是被减去 5 乘 sizeof(int)，新的 ptr 指向的地址将比原来的 ptr 所指向的地址向低地址方向移动了 20 个字节。<br>下面请允许我再举一个例子(一个误区):<br><strong>例五:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">20</span>] = <span class="string">&quot;You_are_a_girl&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *p = a;</span><br><span class="line">    <span class="keyword">char</span> **ptr = &amp;p;</span><br><span class="line">    <span class="comment">// printf(&quot;p = %d\n&quot;,p);</span></span><br><span class="line">    <span class="comment">// printf(&quot;ptr = %d\n&quot;,ptr);</span></span><br><span class="line">    <span class="comment">// printf(&quot;*ptr = %d\n&quot;,*ptr);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**ptr = %c\n&quot;</span>,**ptr);</span><br><span class="line">    ptr++;</span><br><span class="line">    <span class="comment">// printf(&quot;ptr = %d\n&quot;,ptr);</span></span><br><span class="line">    <span class="comment">// printf(&quot;*ptr = %d\n&quot;,*ptr);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**ptr = %c\n&quot;</span>,**ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>误区一</strong><br>输出答案为 Y 和 o<br><strong>误解：</strong> ptr 是一个 char 的二级指针，当执行 ptr++；时,会使指针加一个 sizeof(char)，所以输出如上结果，这个可能只是少部分人的结果。</li>
<li><strong>误区二</strong><br>输出答案为 Y 和 a<br><strong>误解：</strong> ptr 指向的是一个 char * 类型，当执行 ptr++；时，会使指针加一个 sizeof(char *) （有可能会有人认为这个值为 1，那就会得到误区一的答案，这个值应该是 4，参考前面内容）， 即 &amp;p+4；那进行一次取值运算不就指向数组中的第五个元素了吗？那输出的结果不就是数组中第五个元素了吗？答案是<strong>否定</strong>的。<br><strong>正解：</strong> ptr 的类型是 char **，指向的类型是一个 char * 类型，该指向的地址就是 p 的地址 (&amp;p)，当执行 ptr++；时，会使指针加一个 sizeof(char*)，即 &amp;p+4；那 *(&amp;p+4) 指向哪呢，这个你去问上帝吧，或许他会告诉你在哪？所以最后的输出会是一个随机的值，或许是一个非法操作。<br><strong>总结一下:</strong><br>一个指针 ptr_old 加(减)一个整数 n 后，结果是一个新的指针 ptr_new，ptr_new 的类型和 ptr_old 的类型相同，ptr_new 所指向的类型和 ptr_old 所指向的类型也相同。ptr_new 的值将比 ptr_old 的值增加(减少)了 n 乘 sizeof(ptr_old 所指向的类型) 个字节。就是说，ptr_new 所指向的内存区将比 ptr_old 所指向的内存区向高(低)地址方向移动了n 乘 sizeof(ptr_old 所指向的类型) 个字节。指针和指针进行加减：两个指针不能进行加法运算，这是非法操作，因为进行加法后，得到的结果指向一个不知所向的地方，而且毫无意义。两个指针可以进行减法操作，但必须类型相同，一般用在数组方面，不多说了。<h1 id="三、-运算符-amp-和"><a href="#三、-运算符-amp-和" class="headerlink" title="三、 运算符 &amp; 和 *"></a>三、 运算符 &amp; 和 *</h1><blockquote>
<p>这里 &amp; 是取地址运算符，* 是间接运算符。&amp;a 的运算结果是一个指针，指针的类型是 a 的类型加个 *，指针所指向的类型是 a 的类型，指针所指向的地址嘛，那就是 a 的地址。*p 的运算结果就五花八门了。总之 *p 的结果是 p 所指向的东西，这个东西有这些特点：它的类型是 p 指向的类型，它所占用的地址是 p 所指向的地址。</p>
</blockquote>
</li>
</ul>
<p><strong>例六：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">12</span>; </span><br><span class="line"><span class="keyword">int</span> b; </span><br><span class="line"><span class="keyword">int</span> *p; </span><br><span class="line"><span class="keyword">int</span> **ptr;</span><br><span class="line">p = &amp;a;      <span class="comment">/* &amp;a 的结果是一个指针，类型是 int *，指向的类型是 int，指向的地址是 a 的地址。*/</span></span><br><span class="line">*p = <span class="number">24</span>;     <span class="comment">/* *p 的结果，在这里它的类型是 int，它所占用的地址是 p 所指向的地址，显然，*p 就是变量 a 。*/</span></span><br><span class="line">ptr = &amp;p;    <span class="comment">/* &amp;p 的结果是个指针，该指针的类型是 p 的类型加个 *，在这里是 int **。该指针所指向的类型是 p 的类型，这里是 int *。该指针所指向的地址就是指针 p 自己的地址。*/</span></span><br><span class="line">*ptr = &amp;b;   <span class="comment">/* *ptr 是个指针，&amp;b 的结果也是个指针，且这两个指针的类型和所指向的类型是一样的，所以用 &amp;b 来给 *ptr 赋值就是毫无问题的了。*/</span></span><br><span class="line">**ptr = <span class="number">34</span>;  <span class="comment">/* *ptr 的结果是 ptr 所指向的东西，在这里是一个指针，对这个指针再做一次 * 运算，结果是一个 int 类型的变量。*/</span></span><br></pre></td></tr></table></figure>
<h1 id="四、-指针表达式"><a href="#四、-指针表达式" class="headerlink" title="四、 指针表达式"></a>四、 指针表达式</h1><p>一个表达式的结果如果是一个指针，那么这个表达式就叫指针表式。<br>下面是一些指针表达式的例子：<br><strong>例七：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *pa;</span><br><span class="line">pa = &amp;a;         <span class="comment">/* &amp;a 是一个指针表达式。*/</span></span><br><span class="line"><span class="keyword">int</span> **ptr = &amp;pa; <span class="comment">/* &amp;pa 也是一个指针表达式。*/</span></span><br><span class="line">*ptr = &amp;b;       <span class="comment">/* *ptr 和 &amp;b 都是指针表达式。*/</span></span><br><span class="line">pa = <span class="built_in">array</span>;</span><br><span class="line">pa++;            <span class="comment">/* 这也是指针表达式。*/</span></span><br></pre></td></tr></table></figure>
<p><strong>例八：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *arr[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> **parr = arr; <span class="comment">/* 如果把 arr 看作指针的话，arr 也是指针表达式。 */</span></span><br><span class="line"><span class="keyword">char</span> *str;</span><br><span class="line">str = *parr;       <span class="comment">/* *parr 是指针表达式。*/</span></span><br><span class="line">str = *(parr+<span class="number">1</span>);   <span class="comment">/* *(parr+1) 是指针表达式。*/</span></span><br><span class="line">str = *(parr+<span class="number">2</span>);   <span class="comment">/* *(parr+2) 是指针表达式。*/</span></span><br></pre></td></tr></table></figure>
<p>由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。<br>好了，当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。在例七中，&amp;a 不是一个左值，因为它还没有占据明确的内存。*ptr 是一个左值，因为 *ptr 这个指针已经占据了内存，其实 *ptr 就是指针 pa，既然 pa 已经在内存中有了自己的位置，那么 *ptr 当然也有了自己的位置。</p>
<h1 id="五、数组和指针的关系"><a href="#五、数组和指针的关系" class="headerlink" title="五、数组和指针的关系"></a>五、数组和指针的关系</h1><p>数组的数组名其实可以看作一个指针。看下例：<br><strong>例九：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;, value;</span><br><span class="line">value = <span class="built_in">array</span>[<span class="number">0</span>]; <span class="comment">/* 也可写成：value = *array; */</span></span><br><span class="line">value = <span class="built_in">array</span>[<span class="number">3</span>]; <span class="comment">/* 也可写成：value = *(array+3); */</span></span><br><span class="line">value = <span class="built_in">array</span>[<span class="number">4</span>]; <span class="comment">/* 也可写成：value = *(array+4); */</span></span><br></pre></td></tr></table></figure>
<p>上例中，一般而言数组名 array 代表数组本身，类型是 int[10]，但如果把 array 看做指针的话，它指向数组的第 0 个单元，类型是 int* 所指向的类型是数组单元的类型即 int。因此 *array 等于 0 就一点也不奇怪了。同理， array + 3 是一个指向数组第 3 个单元的指针，所以 *(array + 3) 等于 3。其它依此类推。<br><strong>例十：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str[<span class="number">3</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;Hello,thisisasample!&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Hi,goodmorning.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Helloworld&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">80</span>]；</span><br><span class="line"><span class="built_in">strcpy</span>(s,str[<span class="number">0</span>]); <span class="comment">/* 也可写成 strcpy(s,*str); */</span></span><br><span class="line"><span class="built_in">strcpy</span>(s,str[<span class="number">1</span>]); <span class="comment">/* 也可写成 strcpy(s,*(str+1)); */</span></span><br><span class="line"><span class="built_in">strcpy</span>(s,str[<span class="number">2</span>]); <span class="comment">/* 也可写成 strcpy(s,*(str+2)); */</span></span><br></pre></td></tr></table></figure>
<p>上例中，str 是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指针数组名 str 当作一个指针的话，它指向数组的第 0 号单元，它的类型是 char **，它指向的类型是 char *。<br>*str 也是一个指针，它的类型是 char *，它所指向的类型是 char，它指向的地址是字符串 “Hello,thisisasample!” 的第一个字符的地址，即 ‘H’ 的地址。注意：字符串相当于是一个数组，在内存中以数组的形式储存，只不过字符串是一个数组常量，内容不可改变，且只能是右值。如果看成指针的话,他即是常量指针，也是指针常量。<br>str+1 也是一个指针，它指向数组的第 1 号单元，它的类型是 char**，它指向的类型是 char*。<br>*(str+1) 也是一个指针，它的类型是 char*，它所指向的类型是 char，它指向 “Hi,goodmorning.” 的第一个字符 ‘H’。</p>
<p><strong>下面总结一下数组的数组名(数组中储存的也是数组)的问题:</strong></p>
<blockquote>
<p>声明了一个数组 TYPE array[n]，则数组名称 array 就有了两重含义：<br>第一，它代表整个数组，它的类型是 TYPE[n]；<br>第二，它是一个常量指针，该指针的类型是 TYPE*，该指针指向的类型是 TYPE，也就是数组单元的类型，该指针指向的内存区就是数组第 0 号单元，该指针自己占有单独的内存区，注意它和数组第 0 号单元占据的内存区是不同的。该指针的值是不能修改的，即类似 array++ 的表达式是错误的。在不同的表达式中数组名 array 可以扮演不同的角色。在表达式 sizeof(array) 中，数组名 array 代表数组本身，故这时 sizeof 函数测出的是整个数组的大小。在表达式 *array 中，array 扮演的是指针，因此这个表达式的结果就是数组第 0 号单元的值。sizeof(*array) 测出的是数组单元的大小。表达式 array + n（其中 n = 0，1，2，…..）中，array 扮演的是指针，故 array + n 的结果是一个指针，它的类型是 TYPE *，它指向的类型是 TYPE，它指向数组第 n 号单元。故 sizeof(array+n) 测出的是指针类型的大小。在 32 位程序中结果是 4。</p>
</blockquote>
<p><strong>例十一：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> (*ptr)[<span class="number">10</span>];</span><br><span class="line">ptr = &amp;<span class="built_in">array</span>;</span><br></pre></td></tr></table></figure>
<p>上例中 ptr 是一个指针，它的类型是 int(*)[10]，他指向的类型是 int[10] ，我们用整个数组的首地址来初始化它。在语句 ptr = &amp;array 中，array 代表数组本身。<br>本节中提到了函数 sizeof()，那么我来问一问，sizeof(指针名称)  测出的究竟是指针自身类型的大小呢还是指针所指向的类型的大小？<br>答案是：<strong>前者</strong>。<br><strong>例如：</strong></p>
<blockquote>
<p>int (*ptr)[10];<br>则在 32 位程序中，有：<br>sizeof(int(*)[10]) == 4<br>sizeof(int[10]) == 40<br>sizeof(ptr) == 4<br>实际上，sizeof(对象) 测出的都是对象自身的类型的大小，而不是别的什么类型的大小。</p>
</blockquote>
<h1 id="六、-指针和结构类型的关系"><a href="#六、-指针和结构类型的关系" class="headerlink" title="六、 指针和结构类型的关系"></a>六、 指针和结构类型的关系</h1><p>可以声明一个指向结构类型对象的指针。<br><strong>例十二：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 声明了结构对象 ss，并把 ss 的成员初始化为 20，30 和 40。*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> <span class="title">ss</span> =</span> &#123;<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;;</span><br><span class="line"><span class="comment">/* 声明了一个指向结构对象 ss 的指针。它的类型是 MyStruct *，它指向的类型是 MyStruct。*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> *<span class="title">ptr</span> =</span> &amp;ss;</span><br><span class="line"><span class="comment">/* 声明了一个指向结构对象 ss 的指针。但是 pstr 和它被指向的类型 ptr 是不同的。*/</span></span><br><span class="line"><span class="keyword">int</span> *pstr = (<span class="keyword">int</span>*) &amp;ss;</span><br></pre></td></tr></table></figure>
<p>请问怎样通过指针 ptr 来访问 ss 的三个成员变量？<br><strong>答案：</strong></p>
<blockquote>
<p>ptr -&gt; a; // 指向运算符，或者可以这们 (*ptr).a，建议使用前者。<br>ptr -&gt; b;<br>ptr -&gt; c;</p>
</blockquote>
<p>又请问怎样通过指针 pstr 来访问 ss 的三个成员变量？<br><strong>答案：</strong></p>
<blockquote>
<p>*pstr； &nbsp;&nbsp;&nbsp;&nbsp;// 访问了ss 的成员 a。<br>*(pstr+1); // 访问了ss 的成员 b。<br>*(pstr+2) &nbsp;// 访问了ss 的成员 c。<br>虽然我在我的 MSVC++6.0 上调式过上述代码，但是要知道，这样使用 pstr 来访问结构成员是不正规的，为了说明为什么不正规，让我们看看怎样通过指针来访问数组的各个单元: (将结构体换成数组)</p>
</blockquote>
<p><strong>例十三：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">3</span>] = &#123;<span class="number">35</span>, <span class="number">56</span>, <span class="number">37</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *pa = <span class="built_in">array</span>;</span><br><span class="line"><span class="comment">// 通过指针 pa 访问数组 array 的三个单元的方法是：</span></span><br><span class="line">*pa;     <span class="comment">/* 访问了第 0 号单元 */</span></span><br><span class="line">*(pa+<span class="number">1</span>); <span class="comment">/* 访问了第 1 号单元 */</span></span><br><span class="line">*(pa+<span class="number">2</span>); <span class="comment">/* 访问了第 2 号单元 */</span></span><br></pre></td></tr></table></figure>
<p>从格式上看倒是与通过指针访问结构成员的不正规方法的格式一样。<br>所有的 C/C++ 编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙。但在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个”填充字节”，这就导致各个成员之间可能会有若干个字节的空隙。<br>所以，在例十二中，即使 *pstr 访问到了结构对象 ss 的第一个成员变量 a，也不能保证 *(pstr+1) 就一定能访问到结构成员 b。因为成员 a 和成员 b 之间可能会有若干填充字节，说不定 *(pstr+1) 就正好访问到了这些填充字节呢。这也证明了指针的灵活性。要是你的目的就是想看看各个结构成员之间到底有没有填充字节，嘿，这倒是个不错的方法。<br>不过指针访问结构成员的正确方法应该是像例十二中使用指针 ptr 的方法。</p>
<h1 id="七、指针和函数的关系"><a href="#七、指针和函数的关系" class="headerlink" title="七、指针和函数的关系"></a>七、指针和函数的关系</h1><p>可以把一个指针声明成为一个指向函数的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">char</span> *,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*pfun1)(<span class="keyword">char</span> *,<span class="keyword">int</span>);</span><br><span class="line">pfun1 = fun1;</span><br><span class="line"><span class="keyword">int</span> a = (*pfun1)(<span class="string">&quot;abcdefg&quot;</span>,<span class="number">7</span>); <span class="comment">/* 通过函数指针调用函数。*/</span></span><br></pre></td></tr></table></figure>
<p>可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。<br><strong>例十四：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">&quot;abcdefghijklmn&quot;</span>;</span><br><span class="line">a = fun(str);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> length = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num += *s;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中的函数 fun 统计一个字符串中各个字符的 ASCII 码值之和。前面说了，数组的名字也是一个指针。在函数调用中，当把 str 作为实参传递给形参 s 后，实际是把 str 的值传递给了 s，s 所指向的地址就和 str 所指向的地址一致，但是 str 和 s 各自占用各自的存储空间。在函数体内对 s 进行自加 1 运算，并不意味着同时对 str 进行了自加 1 运算。</p>
<h1 id="八、-指针类型转换"><a href="#八、-指针类型转换" class="headerlink" title="八、 指针类型转换"></a>八、 指针类型转换</h1><p>当我们初始化一个指针或给一个指针赋值时，赋值号的左边是一个指针，赋值号的右边是一个指针表达式。在我们前面所举的例子中，绝大多数情况下，指针的类型和指针表达式的类型是一样的，指针所指向的类型和指针表达式所指向的类型是一样的。<br><strong>例十五：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">12.3</span>;</span><br><span class="line"><span class="keyword">float</span> *fptr = &amp;f;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，假如我们想让指针 p 指向实数 f，应该怎么办？是用下面的语句吗？<br>p = &f;<br><strong>不对</strong>。因为指针 p 的类型是 int *，它指向的类型是 int。表达式 &amp;f 的结果是一个指针，指针的类型是 float *，它指向的类型是 float。<br>两者不一致，直接赋值的方法是不行的。至少在我的 MSVC++6.0 上，对指针的赋值语句要求赋值号两边的类型一致，所指向的类型也一致，其它的编译器上我没试过，大家可以试试。为了实现我们的目的，需要进行 “强制类型转换” :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = (int*) &amp;f;</span><br></pre></td></tr></table></figure>
<p>如果有一个指针 p，我们需要把它的类型和所指向的类型改为 TYEP *TYPE， 那么语法格式是： (TYPE *) p；<br>这样强制类型转换的结果是一个新指针，该新指针的类型是 TYPE *，它指向的类型是 TYPE，它指向的地址就是原指针指向的地址。<br>而原来的指针 p 的一切属性都没有被修改。（<strong>切记</strong>）<br>一个函数如果使用了指针作为形参，那么在函数调用语句的实参和形参的结合过程中，必须保证类型一致，否则需要强制转换<br><strong>例十六：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">125</span>,b;</span><br><span class="line">fun((<span class="keyword">char</span>*) &amp;a);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	c = *(s+<span class="number">3</span>);</span><br><span class="line">    *(s+<span class="number">3</span>) = *(s+<span class="number">0</span>);</span><br><span class="line">    *(s+<span class="number">0</span>) = c;</span><br><span class="line">	c = *(s+<span class="number">2</span>);</span><br><span class="line">    *(s+<span class="number">2</span>) = *(s+<span class="number">1</span>);</span><br><span class="line">    *(s+<span class="number">1</span>) = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这是一个 32 位程序，故 int 类型占了四个字节，char 类型占一个字节。函数 fun 的作用是把一个整数的四个字节的顺序来个颠倒。注意到了吗？在函数调用语句中，实参 &amp;a 的结果是一个指针，它的类型是 int *，它指向的类型是 int。形参这个指针的类型是 char *，它指向的类型是 char。这样，在实参和形参的结合过程中，我们必须进行一次从 int * 类型到 char * 类型的转换。<br>结合这个例子，我们可以这样来想象编译器进行转换的过程：编译器先构造一个临时指针 char *temp，然后执行temp = (char *) &amp;a，最后再把 temp 的值传递给 s。所以最后的结果是：s 的类型是 char *，它指向的类型是 char，它指向的地址就是 a 的首地址。<br>我们已经知道，指针的值就是指针指向的地址，在 32 位程序中，指针的值其实是一个 32 位整数。<br>那可不可以把一个整数当作指针的值直接赋给指针呢？就象下面的语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a;</span><br><span class="line">TYPE *ptr;        <span class="comment">/* TYPE 是 int，char 或结构类型等等类型。*/</span></span><br><span class="line">a = <span class="number">20345686</span>;</span><br><span class="line">ptr = <span class="number">20345686</span>;   <span class="comment">/* 我们的目的是要使指针 ptr 指向地址 20345686。*/</span></span><br><span class="line">ptr = a;          <span class="comment">/* 我们的目的是要使指针 ptr 指向地址 20345686 编译一下吧。结果发现后面两条语句全是错的。那么我们的目的就不能达到了吗？不，还有办法：*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a;</span><br><span class="line">TYPE *ptr;        <span class="comment">/* TYPE 是 int，char 或结构类型等等类型。*/</span></span><br><span class="line">a = N             <span class="comment">/* N 必须代表一个合法的地址；*/</span></span><br><span class="line">ptr = (TYPE*) a； <span class="comment">/* 呵呵，这就可以了。*/</span></span><br></pre></td></tr></table></figure>
<p>严格说来这里的 (TYPE *) 和指针类型转换中的 (TYPE *) 还不一样。这里的 (TYPE *) 的意思是把无符号整数 a 的值当作一个地址来看待。上面强调了 a 的值必须代表一个合法的地址，否则的话，在你使用 ptr 的时候，就会出现非法操作错误。想想能不能反过来，把指针指向的地址即指针的值当作一个整数取出来。完全可以。下面的例子演示了把一个指针的值当作一个整数取出来，然后再把这个整数当作一个地址赋给一个指针：<br><strong>例十七：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">123</span>, b;</span><br><span class="line"><span class="keyword">int</span> *ptr = &amp;a;</span><br><span class="line"><span class="keyword">char</span> *str;</span><br><span class="line">b = (<span class="keyword">int</span>) ptr;   <span class="comment">/* 把指针 ptr 的值当作一个整数取出来。*/</span></span><br><span class="line">str = (<span class="keyword">char</span>*) b; <span class="comment">/* 把这个整数的值当作一个地址赋给指针 str。*/</span></span><br></pre></td></tr></table></figure>

<p>现在我们已经知道了，可以把指针的值当作一个整数取出来，也可以把一个整数值当作地址赋给一个指针。</p>
<h1 id="九、-指针的安全问题"><a href="#九、-指针的安全问题" class="headerlink" title="九、 指针的安全问题"></a>九、 指针的安全问题</h1><p>看下面的例子：<br><strong>例十八：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> *ptr;</span><br><span class="line">ptr = (<span class="keyword">int</span> *) &amp;s;</span><br><span class="line">*ptr = <span class="number">1298</span>；</span><br></pre></td></tr></table></figure>
<p>指针 ptr 是一个 int * 类型的指针，它指向的类型是 int。它指向的地址就是 s 的首地址。在 32 位程序中，s 占一个字节，int 类型占四个字节。最后一条语句不但改变了 s 所占的一个字节，还把和 s 相临的高地址方向的三个字节也改变了。这三个字节是干什么的？只有编译程序知道，而写程序的人是不太可能知道的。也许这三个字节里存储了非常重要的数据，也许这三个字节里正好是程序的一条代码，而由于你对指针的马虎应用，这三个字节的值被改变了！这会造成崩溃性的错误。<br>让我们再来看一例：<br><strong>例十九：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a;</span><br><span class="line"><span class="keyword">int</span> *ptr = &amp;a;</span><br><span class="line">ptr++;</span><br><span class="line">*ptr = <span class="number">115</span>;</span><br></pre></td></tr></table></figure>
<p>该例子完全可以通过编译，并能执行。但是看到没有？第 3 句对指针 ptr 进行自加 1 运算后，ptr 指向了和整形变量 a 相邻的高地址方向的一块存储区。这块存储区里是什么？我们不知道。有可能它是一个非常重要的数据，甚至可能是一条代码。<br>而第 4 句竟然往这片存储区里写入一个数据！这是严重的错误。所以在使用指针时，程序员心里必须非常清楚：我的指针究竟指向了哪里。在用指针访问数组的时候，也要注意不要超出数组的低端和高端界限，否则也会造成类似的错误。<br>在指针的强制类型转换：ptr1 = (TYPE *) ptr2 中，如果 sizeof(ptr2 的类型) 大于 sizeof(ptr1 的类型)，那么在使用指针 ptr1 来访问 ptr2 所指向的存储区时是安全的。如果 sizeof(ptr2 的类型) 小于 sizeof(ptr1 的类型)，那么在使用指针 ptr1 来访问 ptr2 所指向的存储区时是不安全的。至于为什么，读者结合例十八来想一想，应该会明白的。</p>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/soonfly/article/details/51131141">【让你不再害怕指针—— C 指针详解(经典,非常详细)】</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/articles/page/61/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/articles/">1</a><span class="space">&hellip;</span><a class="page-number" href="/articles/page/61/">61</a><span class="page-number current">62</span><a class="page-number" href="/articles/page/63/">63</a><span class="space">&hellip;</span><a class="page-number" href="/articles/page/67/">67</a><a class="extend next" rel="next" href="/articles/page/63/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Tubetrue01"
      src="/articles/img/head.PNG">
  <p class="site-author-name" itemprop="name">Tubetrue01</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/articles/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/articles/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Tubetrue01" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Tubetrue01" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tubetrue01</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/articles/libs/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script>
  <script src="/articles/libs/velocity/velocity.min.js"></script>
  <script src="/articles/libs/velocity/velocity.ui.min.js"></script>

<script src="/articles/js/utils.js"></script>

<script src="/articles/js/motion.js"></script>


<script src="/articles/js/schemes/pisces.js"></script>


<script src="/articles/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  


    </div>
</body>
</html>
