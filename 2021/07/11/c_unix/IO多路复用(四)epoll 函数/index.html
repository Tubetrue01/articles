<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/articles/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/articles/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/articles/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/articles/images/logo.svg" color="#222">

<link rel="stylesheet" href="/articles/css/main.css">


<link rel="stylesheet" href="/articles/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tubetrue01.github.io","root":"/articles/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="引言 epoll 是 Linux 特有的结构，它允许一个进程监听多个文件描述符，并在 I&#x2F;O 就绪时获取到通知。epoll 有 ET（edge-triggered） 跟 LT（level-triggered） 两种对文件描述符的操作模式，默认为 LT。在我们深入了解它之前，让我们先看看它的语法。  epll 语法与 poll 不同的是，epoll 本身并不是一个系统调用。它是一个允许进程在多个文件">
<meta property="og:type" content="article">
<meta property="og:title" content="IO 多路复用（四）epoll 函数">
<meta property="og:url" content="https://tubetrue01.github.io/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/">
<meta property="og:site_name" content="Tubetrue01">
<meta property="og:description" content="引言 epoll 是 Linux 特有的结构，它允许一个进程监听多个文件描述符，并在 I&#x2F;O 就绪时获取到通知。epoll 有 ET（edge-triggered） 跟 LT（level-triggered） 两种对文件描述符的操作模式，默认为 LT。在我们深入了解它之前，让我们先看看它的语法。  epll 语法与 poll 不同的是，epoll 本身并不是一个系统调用。它是一个允许进程在多个文件">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tubetrue01.github.io/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/01.png">
<meta property="og:image" content="https://tubetrue01.github.io/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/02.png">
<meta property="og:image" content="https://tubetrue01.github.io/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/03.png">
<meta property="og:image" content="https://tubetrue01.github.io/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/04.png">
<meta property="og:image" content="https://tubetrue01.github.io/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/05.png">
<meta property="og:image" content="https://tubetrue01.github.io/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/06.png">
<meta property="og:image" content="https://tubetrue01.github.io/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/07.png">
<meta property="og:image" content="https://tubetrue01.github.io/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/08.png">
<meta property="og:image" content="https://tubetrue01.github.io/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/09.png">
<meta property="og:image" content="https://tubetrue01.github.io/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/10.png">
<meta property="og:image" content="https://tubetrue01.github.io/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/11.png">
<meta property="og:image" content="https://tubetrue01.github.io/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/12.png">
<meta property="og:image" content="https://tubetrue01.github.io/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/13.png">
<meta property="og:image" content="https://tubetrue01.github.io/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/14.png">
<meta property="og:image" content="https://tubetrue01.github.io/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/15.png">
<meta property="og:image" content="https://tubetrue01.github.io/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/16.png">
<meta property="og:image" content="https://tubetrue01.github.io/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/17.png">
<meta property="og:image" content="https://tubetrue01.github.io/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/18.png">
<meta property="og:image" content="https://tubetrue01.github.io/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/19.png">
<meta property="og:image" content="https://tubetrue01.github.io/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/20.png">
<meta property="article:published_time" content="2021-07-11T07:55:10.000Z">
<meta property="article:modified_time" content="2021-10-12T06:18:28.000Z">
<meta property="article:author" content="Tubetrue01">
<meta property="article:tag" content="Unix">
<meta property="article:tag" content="C">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tubetrue01.github.io/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/01.png">

<link rel="canonical" href="https://tubetrue01.github.io/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>IO 多路复用（四）epoll 函数 | Tubetrue01</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/articles/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tubetrue01</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/articles/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/articles/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/articles/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tubetrue01.github.io/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/articles/img/head.PNG">
      <meta itemprop="name" content="Tubetrue01">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tubetrue01">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          IO 多路复用（四）epoll 函数
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-11 15:55:10" itemprop="dateCreated datePublished" datetime="2021-07-11T15:55:10+08:00">2021-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-12 14:18:28" itemprop="dateModified" datetime="2021-10-12T14:18:28+08:00">2021-10-12</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote>
<p>epoll 是 Linux 特有的结构，它允许一个进程监听多个文件描述符，并在 I/O 就绪时获取到通知。epoll 有 ET（edge-triggered） 跟 LT（level-triggered） 两种对文件描述符的操作模式，默认为 LT。在我们深入了解它之前，让我们先看看它的语法。</p>
</blockquote>
<h1 id="epll-语法"><a href="#epll-语法" class="headerlink" title="epll 语法"></a>epll 语法</h1><p>与 poll 不同的是，epoll 本身并不是一个系统调用。它是一个允许进程在多个文件描述符上复用 I/O 的内核数据结构。</p>
<hr>
<img src="/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/01.png" class="" width="400">

<hr>
<p>该数据结构通过以下三个系统调用创建、修改、删除。</p>
<h2 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h2><p><strong>epoll_create</strong> 用于创建 epoll 实例，并返回一个文件描述符给 epoll 实例。方法签名如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>size</strong> 参数用来告知内核进程想要监听的文件描述符数量，以此来辅助内核推算出 epoll 实例的大小。但是，从 Linux 2.6.8 起，epoll 数据结构可以随着文件描述符的添加、删除动态调整，所以该参数就可忽略了。</p>
<p><strong>epoll_create</strong> 返回一个文件描述符给新创建的 epll 内核数据结构。调用进程可以通过该描述进行添加、删除、修改它想要监听 I/O 的其他描述符 给 epoll 实例。</p>
<hr>
<img src="/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/02.png" class="" width="400">

<hr>
<p>另一个 <strong>epoll_create1</strong> 的系统调用签名如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>flag</strong> 参数既可以是 0 也可以是 <strong>EPOLL_CLOEXEC</strong>。</p>
<p>当 flag 为 0 的时候，该函数的行为跟 epoll_create 一致。</p>
<p>当 flag 为 <strong>EPOLL_CLOEXEC</strong> 时，当前进程 fork 出来的任何子进程在执行前都会关闭 epoll 描述符。也因此，子进程不能够访问 epoll 实例。</p>
<p><strong>📚 Tips</strong></p>
<blockquote>
<p>有一点需要特别注意，关联 epoll 实例的文件描述符需要通过 <strong>close()</strong> 系统调用来释放。多个进程可能持有同一个 epoll 实例的文件描述符（如：当 <strong>EPOLL_CLOEXEC</strong> 标记没有指定时，fork 出来的子进程会复制该文件描述符）。当所有的进程都不再使用该描述符时（通过调用 close() 或者退出），内核才会销毁 epoll 实例。</p>
</blockquote>
<h2 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h2><p>进程可以通过 epoll_ctl 来添加它想要监听的描述符给 epoll 实例。所有注册到 epoll 实例的文件描述符统称为 <strong>epoll set</strong> 或者 <strong>interest list</strong>。</p>
<hr>
<img src="/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/03.png" class="" width="400">

<hr>
<p>上图中，pid 为 483 的进程在 epoll 实例中注册了 FD1，FD2，FD3，FD4，FD5 文件描述符。以上就是 epoll 实例的 interest list 或者 epoll set。随后，当任何文件描述符已经准备好 I/O 时，它们就会放到 ready list 中。</p>
<p>ready list 是 interest list 的子集，如图所示：</p>
<hr>
<img src="/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/04.png" class="" width="400">

<hr>
<p><strong>epoll_ctl</strong> 的签名如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure>
<hr>
<img src="/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/05.png" class="" width="400">

<hr>
<ul>
<li><p><strong>epfd</strong> 由 <strong>epoll_create</strong> 返回的 epoll 文件描述符，指向内核中 epoll 实例。</p>
</li>
<li><p><strong>fd</strong> 需要注册到 epoll list 或者 interest list 中的文件描述符。</p>
</li>
<li><p><strong>op</strong> 对以上文件描述符 fd 要执行的操作，一般支持以下三个操作：</p>
</li>
<li><p><strong>EPOLL_CTL_ADD</strong> 向 epoll 实例中注册该文件描述符，当指定事件发生时，获取到通知。</p>
</li>
<li><p><strong>EPOLL_CTL_DEL</strong> 将该文件描述符从 eopll 实例中删除，意味着进程不会收到任何发生在该文件描述符上事件的通知。</p>
</li>
<li><p><strong>EPOLL_CTL_MOD</strong> 修改该文件描述符上的监听事件。</p>
</li>
</ul>
<hr>
<img src="/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/06.png" class="" width="400">

<hr>
<p><strong>event</strong> 指向存储想要在该文件描述符监听事件的 <strong>epoll_event</strong> 结构的指针。</p>
<hr>
<img src="/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/07.png" class="" width="400">

<hr>
<p>以下是 epoll_event 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> events;          <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">uint32_t</span> u32;</span><br><span class="line">  <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>

<p>epoll_event 结构的第一个字段 <strong>events</strong> 是一个位掩码，表示 fd 上哪些事件正在监听。</p>
<p>比如：如果 fd 是一个 socket 描述符，我们可能想要监听是否有新的数据到达 socket buffer，那我们可以设置 <strong>EPOLLIN</strong> 事件。如果我们想要获取 fd 上 edge-triggered 触发的通知，可以设置 <strong>EPOLLET</strong> 按位或 <strong>EPOLLIN</strong>等等。</p>
<p>events 可以由以下几种宏表示：</p>
<ul>
<li><strong>EPOLLIN</strong> 表示对应的文件描述符可以读（包括对端 socket 正常关闭）。</li>
<li><strong>EPOLLOUT</strong> 表示对应的文件描述符可以写。</li>
<li><strong>EPOLLPRI</strong> 表示对应的文件描述符有紧急的数据可。</li>
<li><strong>EPOLLERR</strong> 表示对应的文件描述符发生错误；</li>
<li><strong>EPOLLHUP</strong> 表示对应的文件描述符被挂断；</li>
<li><strong>EPOLLET</strong> 将 EPOLL 设为边缘触发（Edge Triggered）模式，这是相对于水平触发（Level Triggered）来说的。</li>
<li><strong>EPOLLONESHOT</strong> 只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个 socket 的话，需要再次把这个 socket 加入到 epoll 队列里</li>
</ul>
<p>更多的用法可以从<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/epoll_ctl.2.html">【man page】</a> 中获取。</p>
<p>epoll_event 的第二个字段是一个联合类型。</p>
<h2 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h2><p>通过 epoll_wait 系统调用通知线程 epoll set/ interest list 上事件的发生，该调用会一直阻塞，直到任何一个被监听的描述符准备好 I/O。</p>
<p>该函数签名如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *evlist, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>epfd</strong> epoll_create 返回的 epoll 文件描述符。</p>
</li>
<li><p><strong>evlist</strong> epoll_event 结构数组。evlist 由调用进程分配，当 epoll_wait 返回时，该数组存放处于 interest list 中就绪状态（ready list）的描述符及对应的事件信息。</p>
</li>
</ul>
<p><strong>maxevents</strong> — evlist 数组的长度。</p>
<p><strong>timeout</strong> — 该参数的行为跟 poll 以及 select 一致，指定 epoll_wait 调用等待时长。</p>
<ul>
<li>当 timeout 为 0 时，epoll_wait 调用在检查 epfd 的 interest list 中哪些文件描述符准备就绪之后立即返回，不会阻塞。</li>
<li>当 timeout 为 -1 时，eopll_wait 会一直阻塞（此时内核会将该进程休眠，直到调用返回）直到一个或者多个处于 interest list 中的描述符变成就绪状态或者该调用被信号处理程序中断。</li>
<li>当 timeout 为一个正值时，epoll_wait 调用会等待 timeout 毫秒数，除非有描述符就绪或者被信号中断。</li>
</ul>
<p>epoll_wait 有以下返回值：</p>
<ul>
<li>-1：当调用发生错误（EBADF or EINTR or EFAULT or EINVAL）。</li>
<li>0：调用超时。</li>
<li>返回就绪的描述符的数量，即 evlist 数组的长度</li>
</ul>
<h1 id="epoll-中的陷阱"><a href="#epoll-中的陷阱" class="headerlink" title="epoll 中的陷阱"></a>epoll 中的陷阱</h1><p>为了充分了解 epoll，我们需要了解文件描述符背后的工作原理是怎样的。<br>每个进程维护一套它能访问到的文件描述符表，表中每个条目都包含两个字段：</p>
<ul>
<li><strong>flags</strong> 用来控制对描述符的操作（唯一相同的 flag 是 close-on-exec）</li>
<li> <strong>ptr</strong> 指向底层内核数据结构的指针</li>
</ul>
<p>描述符既可以被 open、pipe、socket 等系统调用显示地创建，也可以被父进程 fork 出来的子进程继承，或者被 dup/dup2 这样的系统调用“复制”。</p>
<hr>
<img src="/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/08.png" class="" width="400">

<hr>
<p>以下场景会释放描述符：</p>
<ul>
<li>进程退出</li>
<li>close 系统调用</li>
<li>进程调用 fork 派生出来的子进程会继承下来所有父进程的描述符。如果任何在父进程调用 fork 之后，子进程 execs 之前标记为 close-on-exec 的描述符，子进程都不可用，但是父进程仍然可以继续使用这些描述符</li>
</ul>
<p>假如上图中进程 A 描述符 3 被标记为 close-on-exec，当进程 A fork 出进程 B 之后，两者完全相同，进程 B 拥有了继承下来的描述符 0，1，2，3。</p>
<p>但是，由于描述符 3 被标记为 close-on-exec，所以在进程 B execs 之前，该描述符会被标记为“inactive”，进程 B 也就不能够再访问它了。</p>
<hr>
<img src="/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/09.png" class="" width="400">

<hr>
<p>为了弄清它，我们需要知道描述符只是一个指向被称为文件描述符的底层内核数据结构的进程指针。<br>内核维护一个包含所有打开的文件描述符表叫做打开文件表（open file table）。</p>
<hr>
<img src="/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/10.png" class="" width="400">

<hr>
<p>我们假设进程 A 的描述符 fd3 是由 fd0 通过 dup 或者 fcntl 的系统调用创建的。原始的描述符 fd0 以及“复制”出来的描述符 fd3 都指向了内核中同一个文件描述符。</p>
<p>如果进程 A 接着 fork 出进程 B 而 fd3 被标记了 close-on-exec，那么子进程 B 继承下 A 的所有描述符中，fd3 是不能使用的。</p>
<p>有一点需要特别注意的是，子进程中的 fd0 也指向了内核打开文件表中同一个打开的文件描述符。</p>
<hr>
<img src="/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/11.png" class="" width="400">

<hr>
<p>现在有三个描述符，分别是进程 A 中的 fd0 和 fd3，以及进程 B 中的 fd0，它们指向了底层同一个文件描述符。为了简单化，我们忽略掉进程 A 跟进程 B 的其他所有描述符（它们也都分别指向了打开文件表中的一个条目）。</p>
<p><strong>📚 Tips</strong></p>
<blockquote>
<p>注意，文件描述符会在进程以及 fork 出的子进程中共享。如果一个进程通过 Unix Domain Socke 套接字将文件描述符传递给另一个进程，那么两个进程同样会指向底层同一个内核打开的文件描述符。</p>
</blockquote>
<p>最后，我们需要了解另一个比较重要的概念— 文件描述符中的结点指针。<br>结点就是一种文件系统数据结构，它包含有关文件系统对象（如：文件、路径）的相关信息，比如：</p>
<ul>
<li>文件或者路径数据在磁盘上存储的位置</li>
<li>文件或路径属性</li>
<li>访问时间、所有者、权限等关于文件或者路径的元数据信息</li>
</ul>
<p>文件系统中的每个文件或者路径都有一个结点条目，该条目代表着文件的编号（也叫结点编号），在很多文件系统上，可分配的结点数是有上限的。</p>
<p>在磁盘上有一个用于维护结点编号到磁盘上实际结点数据结构映射的结点表。为了获取文件位置或者有关文件的元信息，大部分文件系统使用内核提供的文件驱动通过结点编号来访问它。</p>
<p>假如进程 A fork 出子进程 B 之后，进程 A 又创建了 fd4 跟 fd5（这两个描述符不会被 B 继承）。</p>
<p>假如 fd5 是进程 A 为了读取 abc.txt 文件通过调用 open 来创建的，而进程 B 为了向 abc.txt 文件中写数据通过 open 调用返回的描述符是 fd10。<br>那么进程 A 的 fd5 以及进程 B 的 fd10 指向了打开文件表中不同的文件描述符，但是它们指向的却是同一个节点表中的条目（也就是说，它们指向了同一个文件）。</p>
<hr>
<img src="/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/12.png" class="" width="400">

<hr>
<p>有两点值得注意的地方：</p>
<ul>
<li><p>由于进程 A 以及进程 B 中的 fd0 指向了同一个文件描述符，那么它们就会共享文件偏移量，也就是说，如果进程 A 通过调用 open()、write() 或者 lseek() 等向前移动了偏移量，那么进程 B 中的偏移量同样会发生变化。对于进程 A 的 fd3 也同样如此，因为 fd3 也指向了与 fd0 一样的文件描述符。</p>
</li>
<li><p>以上规则对于其中一个进程修改了文件状态标记（O_ASYNC, O_NONBLOCK, O_APPEND）同样适用。所以，如果进程 B 通过 fd0 使用 fcntl 系统调用将文件描述符改为非阻塞模式，那么进程 A 中的 fd0 跟 fd3 也同样变为非阻塞模式。</p>
</li>
</ul>
<h1 id="剖析-epoll"><a href="#剖析-epoll" class="headerlink" title="剖析 epoll"></a>剖析 epoll</h1><p>假如进程 A 有两个指向不同结点的文件描述符 fd0 跟 fd1。</p>
<hr>
<img src="/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/13.png" class="" width="400">

<hr>
<p>epoll_create 在内核中创建一个新的结点条目（epoll 实例）以及一个新的打开文件描述符，并把指向描述符的 fd9 返回给调用者。</p>
<hr>
<img src="/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/14.png" class="" width="400">

<hr>
<p>当我们通过 epoll_ctl 把 fd0 添加到 epoll 实例的 interest list 中是，实际上是把 fd0 对应的底层文件描述符（打开文件描述符）放到了 epoll 实例的 interest list 中。</p>
<hr>
<img src="/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/15.png" class="" width="400">

<hr>
<p>因此，epoll 实例实际上真正监控的是底层的文件描述符，并不是每个进程的文件描述符，这里有个有趣的现象：</p>
<p>如果进程 A fork 出进程 B，B 就拥有了与 A 一样的描述符，也包括 fd9。不仅如此，进程 B 的 epoll 描述符 fd9 也跟进程 A 一样，拥有相同的 interest list。</p>
<p>如果进程 A 在 fork 之后，创建了一个新的描述符 fd8 （并不会被进程 B 拥有），并通过 epoll_ctl 添加到 interest list 中。当 fd8 上的事件发生时，不仅仅是进程 A 会收到相关的通知，进程 B 也会收到。当通过调用 dup/dup2 复制 epoll 描述符或者通过 Unix Domain Socket 将 epoll 描述符从一个进程传递到另一个进程时，该现象同样会发生。</p>
<hr>
<img src="/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/16.png" class="" width="400">

<hr>
<p>如果进程 B 通过 open 打开一个 df8 指向的文件，其描述符为 fd15，然后进程 A 关闭 fd8。你可能觉得既然 fd8 已经被关闭，那么肯定不会再收到 fd8 上相关的事件了。但是，实际上并非如此，因为 interest list 还在监听着打开的文件描述符。由于 fd15 跟 fd8 指向了相同的描述符，进程 A 得到的通知其实是关于 fd15 的。肯定的是，如果一个进程将它关注的描述符关闭之后还陆续收到该描述符相关的事件，那么该文件描述符对应的底层描述符肯定还被其他至少一个属于该进程或者来自于其他进程的描述引用。</p>
<h1 id="为什么-epoll-性能强于-select-跟-poll"><a href="#为什么-epoll-性能强于-select-跟-poll" class="headerlink" title="为什么 epoll 性能强于 select 跟 poll"></a>为什么 epoll 性能强于 select 跟 poll</h1><p>select/poll 时间复杂度为 O(N)，如果 N 比较大，那么每次 select/poll 被调用时即使就绪的描述符很少，内核也需要扫描集合中的每个描述符。</p>
<p>epoll 监听的是底层的文件描述符，每当文件描述符 IO 就绪时，内核就会把它们添加到 ready list 中，此过程无需进程调用 epoll_wait 来实现。当进程调用 epoll_wait 等待事件发生时，内核除了将它维护的 ready list 返回给调用方外，无需做任何其他额外的工作。</p>
<p>此外，每次调用 select/poll 时，都需要将进程想要监听的描述符信息传递给内核。而内核返回描述符信息时，进程都需要再一次扫描所有的描述符来检查哪个描述符已经就绪了。</p>
<p>对于 epoll，只要我们通过 epoll_ctl 将我们想要监听的描述符添加到 epoll 实例的 interest list 中，我们就不需要将来调用 epoll_wait 时，向内核传递我们想要监听就绪信息的描述符了（select/poll 需要每次调用时传递）。</p>
<p><strong>📚 Tips</strong></p>
<blockquote>
<p>epoll 时间复杂度是 O(就绪的描述符数量) 并非 O(所要监听的描述符数量)。</p>
</blockquote>
<h1 id="边缘触发模式-ET"><a href="#边缘触发模式-ET" class="headerlink" title="边缘触发模式 ET"></a>边缘触发模式 ET</h1><p>默认情况下，epoll 提供了水平触发通知模式。每个 epoll_wait 调用只是返回 interest list 中就绪的描述符。</p>
<p>假如我们注册了 fd1、fd2、fd3、fd4 四个描述符，在我们调用 epoll_wait 时，只有 fd2、fd3 已经就绪了，那么返回的也就只有这两个描述符信息。</p>
<hr>
<img src="/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/17.png" class="" width="400">

<hr>
<p>值得注意的是，在默认的水平触发模式下，由于 epoll 只是在底层描述符就绪时才会更新 ready list，所以 interest list 中的描述符性质（阻塞与非阻塞）并不会影响 epoll_wait 调用的结果。</p>
<p>有时我们只是想查看 interest list 中任何一个描述符的状态，不管它是否已经就绪。边缘触发模式允许我们查看任何特定的描述符（即时在调用 epoll_wait 时还没有就绪）是否 I/O 可用。如果我们想要知道自从上次调用 epoll_wait 以来，文件描述符上是否有任何 I/O 活动发生或者描述符就绪时，epoll_wait 并没有调用，我们可以调用 epoll_ctl 时对 EPOLLET 按位或将描述符注册到 epoll 实例以得到边缘出发模式。</p>
<p>代码示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Poller:register</span><span class="params">(fd, r, w)</span></span></span><br><span class="line">	<span class="keyword">local</span> ev = <span class="built_in">self</span>.ev[<span class="number">0</span>]</span><br><span class="line">    // 事件注册</span><br><span class="line">	ev.events = bit.bor(C.EPOLLET, C.EPOLLERR, C.EPOLLHUP)</span><br><span class="line">	    // 读事件</span><br><span class="line">	<span class="keyword">if</span> r <span class="keyword">then</span></span><br><span class="line">		ev.events = bit.bor(ev.events, C.EPOLLIN)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">if</span> w <span class="keyword">then</span></span><br><span class="line">	    // 写事件</span><br><span class="line">		ev.events = bit.bor(ev.events, C.EPOLLOUT)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	// 将文件描述符设置到事件对象中</span><br><span class="line">	ev.data.u64 = fd</span><br><span class="line">	// 调用 epoll_ctl 注册</span><br><span class="line">	<span class="keyword">local</span> rc = C.epoll_ctl(<span class="built_in">self</span>.fd, C.EPOLL_CTL_ADD, fd, ev)</span><br><span class="line">	<span class="keyword">if</span> rc &lt; <span class="number">0</span> <span class="keyword">then</span> errors.get(rc):abort() <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们以图表的方式来说明边缘触发模式的工作原理。我们采用先前的例子进行说明，进程 A 注册了 4 个描述符到 epoll 实例，其中 fd3 是 socket 描述符。</p>
<p>假如 t1 时刻，输出字节流到到达 fd3 引用的 socket 描述符。</p>
<hr>
<img src="/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/18.png" class="" width="400">

<hr>
<p>假定 t4 时，进程将调用 epoll_wait。</p>
<p>如果 t4 时，fd2、fd3 已经就绪，epoll_wait 调用返回 fd2、fd3 已经就绪。</p>
<hr>
<img src="/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/19.png" class="" width="400">

<hr>
<p>假定进程 t6 时，再一次调用 epoll_wait。<br>此时 fd1 已经就绪，而 fd3 对应的 socket 描述符在 t4 跟 t6 之间没有数据到达。</p>
<p>在水平触发模式下，调用 epoll_wait 将返回 fd1 给进程，因为此时 fd1 是唯一一个就绪的描述符。然而在边缘触发模式下，该调用将会阻塞，因为在 t4 跟 t6 之间没有 socket 数据到达。</p>
<hr>
<img src="/articles/2021/07/11/c_unix/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8(%E5%9B%9B)epoll%20%E5%87%BD%E6%95%B0/20.png" class="" width="400">

<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://copyconstruct.medium.com/the-method-to-epolls-madness-d9d2d6378642">【The method to epoll’s madness】</a></li>
<li><a target="_blank" rel="noopener" href="https://code.woboq.org/gcc/include/sys/epoll.h.html">【epoll.h】</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/articles/tags/Unix/" rel="tag"># Unix</a>
              <a href="/articles/tags/C/" rel="tag"># C</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/articles/2021/05/15/c_reprint/C%E8%BD%AC%E8%BD%BD%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%8F%98%E9%87%8F%E4%B8%8E%E5%86%85%E5%AD%98(%E4%B8%8B%E7%AF%87)/" rel="prev" title="C 转载系列（四）变量与内存（下篇）">
      <i class="fa fa-chevron-left"></i> C 转载系列（四）变量与内存（下篇）
    </a></div>
      <div class="post-nav-item">
    <a href="/articles/2021/08/08/cloud_native/K8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E7%B3%BB%E5%88%97(%E5%9B%9B)%E4%BD%A0%E5%A5%BDIstio/" rel="next" title="K8s 集群搭建系列（四） 你好 Istio">
      K8s 集群搭建系列（四） 你好 Istio <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#epll-%E8%AF%AD%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">epll 语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll-create"><span class="nav-number">2.1.</span> <span class="nav-text">epoll_create</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll-ctl"><span class="nav-number">2.2.</span> <span class="nav-text">epoll_ctl</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll-wait"><span class="nav-number">2.3.</span> <span class="nav-text">epoll_wait</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#epoll-%E4%B8%AD%E7%9A%84%E9%99%B7%E9%98%B1"><span class="nav-number">3.</span> <span class="nav-text">epoll 中的陷阱</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%96%E6%9E%90-epoll"><span class="nav-number">4.</span> <span class="nav-text">剖析 epoll</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-epoll-%E6%80%A7%E8%83%BD%E5%BC%BA%E4%BA%8E-select-%E8%B7%9F-poll"><span class="nav-number">5.</span> <span class="nav-text">为什么 epoll 性能强于 select 跟 poll</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91%E6%A8%A1%E5%BC%8F-ET"><span class="nav-number">6.</span> <span class="nav-text">边缘触发模式 ET</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Tubetrue01"
      src="/articles/img/head.PNG">
  <p class="site-author-name" itemprop="name">Tubetrue01</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/articles/archives/">
        
          <span class="site-state-item-count">68</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/articles/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Tubetrue01" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Tubetrue01" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/articles/Tubetrue01@gmail.com" title="E-Mail → Tubetrue01@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tubetrue01</span>
</div>



        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/articles/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script>
  <script src="/articles/lib/velocity/velocity.min.js"></script>
  <script src="/articles/lib/velocity/velocity.ui.min.js"></script>

<script src="/articles/js/utils.js"></script>

<script src="/articles/js/motion.js"></script>


<script src="/articles/js/schemes/pisces.js"></script>


<script src="/articles/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'b78837f065395b7c4761',
      clientSecret: '58c95c03db39e7430738d663bfc8337a5c8e1e80',
      repo        : 'articles',
      owner       : 'Tubetrue01',
      admin       : ['Tubetrue01'],
      id          : 'f21fe8bb8ab4832f1626b90409213a0a',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
