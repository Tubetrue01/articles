<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/articles/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/articles/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/articles/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/articles/images/logo.svg" color="#222">

<link rel="stylesheet" href="/articles/css/main.css">


<link rel="stylesheet" href="/articles/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tubetrue01.github.io","root":"/articles/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="引言 上篇文章，我们介绍了锁的入口、偏向锁的偏向与撤销。本文继续讲解锁的膨胀。  轻量级锁 系统未启用、偏向失败，synchronized 并不会立即升级成重量级锁，而是尝试使用轻量级锁的一种优化手段，此时 markWord 会变成轻量级锁结构。轻量级锁之所以能够提升性能是依据“对于绝大部分的锁，在整个同步周期内都不存在竞争”。  轻量级锁 markWord 结构  LockRecord如果升级成">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 锁机制之 Synchronized 实现（下）">
<meta property="og:url" content="https://tubetrue01.github.io/2023/04/07/java/Java%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8BSynchronized%E5%AE%9E%E7%8E%B0(%E4%B8%8B)/">
<meta property="og:site_name" content="Tubetrue01">
<meta property="og:description" content="引言 上篇文章，我们介绍了锁的入口、偏向锁的偏向与撤销。本文继续讲解锁的膨胀。  轻量级锁 系统未启用、偏向失败，synchronized 并不会立即升级成重量级锁，而是尝试使用轻量级锁的一种优化手段，此时 markWord 会变成轻量级锁结构。轻量级锁之所以能够提升性能是依据“对于绝大部分的锁，在整个同步周期内都不存在竞争”。  轻量级锁 markWord 结构  LockRecord如果升级成">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tubetrue01.github.io/articles/2023/04/07/java/Java%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8BSynchronized%E5%AE%9E%E7%8E%B0(%E4%B8%8B)/01.jpg">
<meta property="og:image" content="https://tubetrue01.github.io/articles/2023/04/07/java/Java%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8BSynchronized%E5%AE%9E%E7%8E%B0(%E4%B8%8B)/02.jpg">
<meta property="article:published_time" content="2023-04-07T03:37:05.000Z">
<meta property="article:modified_time" content="2024-02-05T05:57:57.432Z">
<meta property="article:author" content="Tubetrue01">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tubetrue01.github.io/articles/2023/04/07/java/Java%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8BSynchronized%E5%AE%9E%E7%8E%B0(%E4%B8%8B)/01.jpg">

<link rel="canonical" href="https://tubetrue01.github.io/2023/04/07/java/Java%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8BSynchronized%E5%AE%9E%E7%8E%B0(%E4%B8%8B)/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java 锁机制之 Synchronized 实现（下） | Tubetrue01</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/articles/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tubetrue01</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/articles/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/articles/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/articles/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tubetrue01.github.io/2023/04/07/java/Java%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8BSynchronized%E5%AE%9E%E7%8E%B0(%E4%B8%8B)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/articles/img/head.PNG">
      <meta itemprop="name" content="Tubetrue01">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tubetrue01">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 锁机制之 Synchronized 实现（下）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-07 11:37:05" itemprop="dateCreated datePublished" datetime="2023-04-07T11:37:05+08:00">2023-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-05 13:57:57" itemprop="dateModified" datetime="2024-02-05T13:57:57+08:00">2024-02-05</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote>
<p>上篇文章，我们介绍了锁的入口、偏向锁的偏向与撤销。本文继续讲解锁的膨胀。</p>
</blockquote>
<h1 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h1><blockquote>
<p>系统未启用、偏向失败，synchronized 并不会立即升级成重量级锁，而是尝试使用轻量级锁的一种优化手段，此时 markWord 会变成轻量级锁结构。轻量级锁之所以能够提升性能是依据“对于绝大部分的锁，在整个同步周期内都不存在竞争”。</p>
</blockquote>
<h2 id="轻量级锁-markWord-结构"><a href="#轻量级锁-markWord-结构" class="headerlink" title="轻量级锁 markWord 结构"></a>轻量级锁 markWord 结构</h2><img src="/articles/2023/04/07/java/Java%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8BSynchronized%E5%AE%9E%E7%8E%B0(%E4%B8%8B)/01.jpg" class="" width="600">

<h3 id="LockRecord"><a href="#LockRecord" class="headerlink" title="LockRecord"></a>LockRecord</h3><p>如果升级成轻量级锁时，当前的 markWord 结构就会变为指向 Lock Record 的指针。其实 Lock Record 并不是在锁升级为轻量级锁时产生的，它在偏向锁阶段就已经产生了。</p>
<h2 id="slow-enter"><a href="#slow-enter" class="headerlink" title="slow_enter"></a>slow_enter</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk/src/share/vm/runtime/synchronizer.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::slow_enter</span><span class="params">(Handle obj, BasicLock* lock, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取当前对象的 markWord，obj-&gt;mark() 实际调用的是 oopDesc 的 mark() 方法</span></span><br><span class="line">  markOop mark = obj-&gt;<span class="built_in">mark</span>();</span><br><span class="line">  <span class="comment">// 此时锁的偏向模式应该是撤销状态，毕竟轻量级锁就没有偏向谁这个概念了</span></span><br><span class="line">  <span class="built_in">assert</span>(!mark-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;should not see bias pattern here&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 判断当前是否是无锁状态，也就是锁的标志位为 01</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">is_neutral</span>()) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把当前对象的 markWord 保存到 displaced mark word</span></span><br><span class="line">    lock-&gt;<span class="built_in">set_displaced_header</span>(mark);</span><br><span class="line">    <span class="comment">// 更新 markWord 使其指向 BasicLock，如果成功，说明获取轻量级锁成功；如果多个线程竞争，那么失败的线程就会继续执行锁的膨胀操作</span></span><br><span class="line">    <span class="keyword">if</span> (mark == (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(lock, <span class="built_in">obj</span>()-&gt;<span class="built_in">mark_addr</span>(), mark)) &#123;</span><br><span class="line">      <span class="built_in">TEVENT</span> (slow_enter: release stacklock) ;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="comment">// 既然已经是有锁状态，先判断锁标志是否为 00（轻量级锁）以及当前线程是否是锁的持有者</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_locker</span>() &amp;&amp; THREAD-&gt;<span class="built_in">is_lock_owned</span>((address)mark-&gt;<span class="built_in">locker</span>())) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(lock != mark-&gt;<span class="built_in">locker</span>(), <span class="string">&quot;must not re-lock the same lock&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(lock != (BasicLock*)obj-&gt;<span class="built_in">mark</span>(), <span class="string">&quot;don&#x27;t relock with same BasicLock&quot;</span>);</span><br><span class="line">    <span class="comment">// 既然是锁的持有者，说明是锁的重入，将 displaced mark word 置空</span></span><br><span class="line">    lock-&gt;<span class="built_in">set_displaced_header</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这个优化可以忽略不计了</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="comment">// The following optimization isn&#x27;t particularly useful.</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_monitor</span>() &amp;&amp; mark-&gt;<span class="built_in">monitor</span>()-&gt;<span class="built_in">is_entered</span>(THREAD)) &#123;</span><br><span class="line">    lock-&gt;<span class="built_in">set_displaced_header</span> (<span class="literal">NULL</span>) ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 走到这，说明设置 displaced 头失败了，那么对于该值是多少也没什么意义。不过为了避免歧义，这里将锁标记设置为 11（3）。</span></span><br><span class="line">  lock-&gt;<span class="built_in">set_displaced_header</span>(markOopDesc::<span class="built_in">unused_mark</span>());</span><br><span class="line">  <span class="comment">// 开始膨胀</span></span><br><span class="line">  ObjectSynchronizer::<span class="built_in">inflate</span>(THREAD, <span class="built_in">obj</span>())-&gt;<span class="built_in">enter</span>(THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>膨胀到轻量级锁时，首先通过对象的 markWord 判断锁的状态。如果是无锁态（锁标记为 01），那么将当前对象的 markWord 复制一份到 LockRecord，通过 CAS 将 markWord 指向 LockRecord。如果成功，说明没有发生竞争，该线程获取到了锁。</p>
<p>如果当前对象有锁（标记为 00）并且当前线程就是锁的持有者，那么说明是锁的重入，此时将 LockRecord 的 markWord 置空。</p>
<p>除此，说明多个线程在竞争锁，那么需要将 RecordLock 中的 markWord 锁标记改为 11，然后进行膨胀。</p>
<h1 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h1><p>此时就属于传统的锁了，markWord 变为重量锁结构，也就是说指向 monitor 的指针：</p>
<img src="/articles/2023/04/07/java/Java%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8BSynchronized%E5%AE%9E%E7%8E%B0(%E4%B8%8B)/02.jpg" class="" width="600">

<h2 id="monitor-对象"><a href="#monitor-对象" class="headerlink" title="monitor 对象"></a>monitor 对象</h2><p>当 markWord 指向 monitor 时，说明此时已经处于重量级锁状态了。我们看下它的结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk/hotspot/src/share/vm/runtime/objectMonitor.hpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只介绍部分相关属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectMonitor</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// markWord 对象头</span></span><br><span class="line">    <span class="keyword">volatile</span> markOop   _header; </span><br><span class="line">    <span class="comment">// 记录个数，_WaitSet + _EntryList</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">intptr_t</span>  _count; </span><br><span class="line">    <span class="comment">// 监视器锁宿主对象，也就是属于哪个对象</span></span><br><span class="line">    <span class="keyword">void</span>*     <span class="keyword">volatile</span> _object; </span><br><span class="line">    <span class="comment">// 多个线程争抢锁，会先存入这个单向链表</span></span><br><span class="line">    ObjectWaiter * <span class="keyword">volatile</span> _cxq;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 等待线程的个数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">intptr_t</span>  _waiters;     </span><br><span class="line">    <span class="comment">// 重入次数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">intptr_t</span>  _recursions; </span><br><span class="line">    <span class="comment">// 拥有该 monitor 对象的线程或者基础锁</span></span><br><span class="line">    <span class="keyword">void</span> *  <span class="keyword">volatile</span>   _owner;</span><br><span class="line">    <span class="comment">// 处于 wait 状态的线程集合，即调用 wait() 方法的线程</span></span><br><span class="line">    ObjectWaiter * <span class="keyword">volatile</span> _WaitSet; </span><br><span class="line">    <span class="comment">// 由于等待锁而 block 的线程集合</span></span><br><span class="line">    ObjectWaiter * <span class="keyword">volatile</span> _EntryList</span><br><span class="line">    <span class="comment">// 上一个拥有 monitor 对象的线程 id</span></span><br><span class="line">    <span class="keyword">volatile</span> jlong _previous_owner_tid;</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">ObjectMonitor</span>() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>;</span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;</span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>;</span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ;</span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">    _previous_owner_tid = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>了解了 monitor 对象结构之后，我们看下锁的膨胀过程：</p>
<h2 id="inflate"><a href="#inflate" class="headerlink" title="inflate"></a>inflate</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk/src/share/vm/runtmie/synchronizer.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ObjectMonitor * ATTR <span class="title">ObjectSynchronizer::inflate</span> <span class="params">(Thread * Self, oop object)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Inflate mutates the heap ...</span></span><br><span class="line">  <span class="comment">// Relaxing assertion for bug 6320749.</span></span><br><span class="line">  <span class="built_in">assert</span> (Universe::<span class="built_in">verify_in_progress</span>() ||</span><br><span class="line">          !SafepointSynchronize::<span class="built_in">is_at_safepoint</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 获取 markWord 对象</span></span><br><span class="line">      <span class="keyword">const</span> markOop mark = object-&gt;<span class="built_in">mark</span>() ;</span><br><span class="line">      <span class="comment">// 此时不应处于偏向模式</span></span><br><span class="line">      <span class="built_in">assert</span> (!mark-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * markWord 可能存在的状态：</span></span><br><span class="line"><span class="comment">       * Inflated        - 膨胀完成，即：拥有了 monitor</span></span><br><span class="line"><span class="comment">       * Stack-locked    - 栈锁定，需要强迫它膨胀</span></span><br><span class="line"><span class="comment">       * INFLATING       - 膨胀中</span></span><br><span class="line"><span class="comment">       * Neutral         - 无锁态，此时正在积极参与膨胀</span></span><br><span class="line"><span class="comment">       * BIASED          - 非法态，理论上不应该出现</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       </span><br><span class="line">      <span class="comment">// 此时已膨胀完成，因为它也已经拥有了 monitor 对象（锁标志为 10）</span></span><br><span class="line">      <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_monitor</span>()) &#123;</span><br><span class="line">          <span class="comment">// 获取当前对象对应的 monitor</span></span><br><span class="line">          ObjectMonitor * inf = mark-&gt;<span class="built_in">monitor</span>() ;</span><br><span class="line">          <span class="comment">// 必须是无锁状态</span></span><br><span class="line">          <span class="built_in">assert</span> (inf-&gt;<span class="built_in">header</span>()-&gt;<span class="built_in">is_neutral</span>(), <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">          <span class="comment">// 对象关联是否一致</span></span><br><span class="line">          <span class="built_in">assert</span> (inf-&gt;<span class="built_in">object</span>() == object, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          <span class="comment">// 验证 monitor 有效性</span></span><br><span class="line">          <span class="built_in">assert</span> (ObjectSynchronizer::<span class="built_in">verify_objmon_isinpool</span>(inf), <span class="string">&quot;monitor is invalid&quot;</span>);</span><br><span class="line">          <span class="comment">// 都没有问题，那就直接返回当前 monitor 对象</span></span><br><span class="line">          <span class="keyword">return</span> inf ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 膨胀中，该状态只是一个暂时的中间态。只有一个线程可以完成膨胀，其他线程都需要等待。</span></span><br><span class="line">      <span class="keyword">if</span> (mark == markOopDesc::<span class="built_in">INFLATING</span>()) &#123;</span><br><span class="line">         <span class="built_in">TEVENT</span> (Inflate: spin <span class="keyword">while</span> INFLATING) ;</span><br><span class="line">         <span class="comment">// 调用 ReadStableMark 方法进行等待，方法内部会调用 os::NakedYield() 释放 CPU 资源</span></span><br><span class="line">         <span class="built_in">ReadStableMark</span>(object) ;</span><br><span class="line">         <span class="keyword">continue</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 如果是栈锁状态，也就是锁标志为 00 的轻量级锁（可能被当前线程持有，也可能被其他线程持有）</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_locker</span>()) &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * 为当前线程分配一个 objectMonitor 对象</span></span><br><span class="line"><span class="comment">           * </span></span><br><span class="line"><span class="comment">           * 如果按照常规方式分配 ObjectMonitor 对象，那么会增加 markWord 中出现 INFLATED 状态的间隔，从而增加锁竞争的概率。</span></span><br><span class="line"><span class="comment">           * 所以这里使用线程私有的空闲 ObjectMonitor 列表分配的方式来降低锁的竞争。</span></span><br><span class="line"><span class="comment">           * 这样还有一个好处就是不用考虑 CAS 设置 INFLATING 的时机。</span></span><br><span class="line"><span class="comment">           * 具体逻辑可以参考 omAlloc 源码。</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          ObjectMonitor * m = <span class="built_in">omAlloc</span> (Self) ;</span><br><span class="line">          <span class="comment">// 初始化 monitor 对象，降低 markWord 出现 INFLATING 的时间</span></span><br><span class="line">          m-&gt;<span class="built_in">Recycle</span>();</span><br><span class="line">          m-&gt;_Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">          m-&gt;OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">          m-&gt;_recursions   = <span class="number">0</span> ;</span><br><span class="line">          m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit ;  </span><br><span class="line"></span><br><span class="line">          <span class="comment">// 将 markWord 设置为 INFLATING 状态</span></span><br><span class="line">          markOop cmp = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span> (markOopDesc::<span class="built_in">INFLATING</span>(), object-&gt;<span class="built_in">mark_addr</span>(), mark) ;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 如果失败了，那就释放掉分配的 monitor 对象</span></span><br><span class="line">         <span class="keyword">if</span> (cmp != mark) &#123;</span><br><span class="line">             <span class="built_in">omRelease</span> (Self, m, <span class="literal">true</span>) ;</span><br><span class="line">             <span class="keyword">continue</span> ;       <span class="comment">// Interference -- just retry</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * 此时，已经成功的将 INFLATING（0）设置到了 markWord 中。这也是唯一成为 INFLATING 的方式。</span></span><br><span class="line"><span class="comment">           * 只有成功设置为 INFLATING（0）的线程才能膨胀成功。</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * 为什么要 CAS 一个 0 到 markWord 而不是直接将 stack-locked 更新到 INFLATED 状态呢？我们需要考虑当线程解锁 stack-locked 时会发生什么。</span></span><br><span class="line"><span class="comment">           * 它会通过 CAS 将 displaced header 的值重新替换掉 markWord。</span></span><br><span class="line"><span class="comment">           * </span></span><br><span class="line"><span class="comment">           * inflate() 例程必须将 header 值从所有者堆栈上的 basiclock 复制到 objectMonitor，同时保证 hashCode 不变。如果持有者在 markWord 为 0 时决定释放锁，那么解锁操作将会失败。最终控制权会从 slow_exit 转为 infalte。持有者将会自旋等待直到 0 值消失。换句话说，处于膨胀阶段，如果持有者释放锁时碰巧是 0 值，那么会导致持有者暂停。重要的一点是，当 ojbect-&gt; mark 为 0 时，mark-&gt;displaced_mark_helper 是稳定版。</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * 而 0 就是作为膨胀过程中的一个“繁忙”标志。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">           </span><br><span class="line">           <span class="comment">// 关闭重量锁的标志位，此时处于无锁状态 0 1</span></span><br><span class="line">          markOop dmw = mark-&gt;<span class="built_in">displaced_mark_helper</span>() ;</span><br><span class="line">          <span class="comment">// 校验无锁</span></span><br><span class="line">          <span class="built_in">assert</span> (dmw-&gt;<span class="built_in">is_neutral</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 设置 monitor header 值</span></span><br><span class="line">          m-&gt;<span class="built_in">set_header</span>(dmw) ;</span><br><span class="line">          <span class="comment">// 拥有该 monitor 对象的基础锁（可以根据与线程的关联关系优化成线程，同时设置字段 m-&gt;OwnerIsThread = 1）</span></span><br><span class="line">          m-&gt;<span class="built_in">set_owner</span>(mark-&gt;<span class="built_in">locker</span>());</span><br><span class="line">          <span class="comment">// 监视器的宿主对象</span></span><br><span class="line">          m-&gt;<span class="built_in">set_object</span>(object);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 确保 monitor 的状态</span></span><br><span class="line">          <span class="built_in">guarantee</span> (object-&gt;<span class="built_in">mark</span>() == markOopDesc::<span class="built_in">INFLATING</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          <span class="comment">// 设置 markWord 值，并且将当前锁基本设置为重量级锁 1 0</span></span><br><span class="line">          object-&gt;<span class="built_in">release_set_mark</span>(markOopDesc::<span class="built_in">encode</span>(m));</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Hopefully the performance counters are allocated on distinct cache lines</span></span><br><span class="line">          <span class="comment">// to avoid false sharing on MP systems ...</span></span><br><span class="line">          <span class="keyword">if</span> (ObjectMonitor::_sync_Inflations != <span class="literal">NULL</span>) ObjectMonitor::_sync_Inflations-&gt;<span class="built_in">inc</span>() ;</span><br><span class="line">          <span class="built_in">TEVENT</span>(Inflate: overwrite stacklock) ;</span><br><span class="line">          <span class="keyword">if</span> (TraceMonitorInflation) &#123;</span><br><span class="line">            <span class="keyword">if</span> (object-&gt;<span class="built_in">is_instance</span>()) &#123;</span><br><span class="line">              ResourceMark rm;</span><br><span class="line">              tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;Inflating object &quot;</span> INTPTR_FORMAT <span class="string">&quot; , mark &quot;</span> INTPTR_FORMAT <span class="string">&quot; , type %s&quot;</span>,</span><br><span class="line">                (<span class="keyword">void</span> *) object, (<span class="keyword">intptr_t</span>) object-&gt;<span class="built_in">mark</span>(),</span><br><span class="line">                object-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">external_name</span>());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 膨胀成功，返回 monitor 对象</span></span><br><span class="line">          <span class="keyword">return</span> m ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 接下来针对于无锁场景</span></span><br><span class="line">      <span class="built_in">assert</span> (mark-&gt;<span class="built_in">is_neutral</span>(), <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">      <span class="comment">// 根据当前线程分配出一个 monitor 对象</span></span><br><span class="line">      ObjectMonitor * m = <span class="built_in">omAlloc</span> (Self) ;</span><br><span class="line">      <span class="comment">// 初始化 monitor 对象</span></span><br><span class="line">      m-&gt;<span class="built_in">Recycle</span>();</span><br><span class="line">      m-&gt;<span class="built_in">set_header</span>(mark);</span><br><span class="line">      m-&gt;<span class="built_in">set_owner</span>(<span class="literal">NULL</span>);</span><br><span class="line">      m-&gt;<span class="built_in">set_object</span>(object);</span><br><span class="line">      <span class="comment">// 既然是无锁，那么持有者就是线程</span></span><br><span class="line">      m-&gt;OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">      m-&gt;_recursions   = <span class="number">0</span> ;</span><br><span class="line">      m-&gt;_Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">      m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit ;       <span class="comment">// consider: keep metastats by type/class</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 将 markWord 指向 monitor 地址</span></span><br><span class="line">      <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (markOopDesc::<span class="built_in">encode</span>(m), object-&gt;<span class="built_in">mark_addr</span>(), mark) != mark) &#123;</span><br><span class="line">          <span class="comment">// 如果竞争失败，那么需要释放 monitor</span></span><br><span class="line">          m-&gt;<span class="built_in">set_object</span> (<span class="literal">NULL</span>) ;</span><br><span class="line">          m-&gt;<span class="built_in">set_owner</span>  (<span class="literal">NULL</span>) ;</span><br><span class="line">          m-&gt;OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">          m-&gt;<span class="built_in">Recycle</span>() ;</span><br><span class="line">          <span class="built_in">omRelease</span> (Self, m, <span class="literal">true</span>) ;</span><br><span class="line">          m = <span class="literal">NULL</span> ;</span><br><span class="line">          <span class="keyword">continue</span> ;</span><br><span class="line">          <span class="comment">// interference - the markword changed - just retry.</span></span><br><span class="line">          <span class="comment">// The state-transitions are one-way, so there&#x27;s no chance of</span></span><br><span class="line">          <span class="comment">// live-lock -- &quot;Inflated&quot; is an absorbing state.</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Hopefully the performance counters are allocated on distinct</span></span><br><span class="line">      <span class="comment">// cache lines to avoid false sharing on MP systems ...</span></span><br><span class="line">      <span class="keyword">if</span> (ObjectMonitor::_sync_Inflations != <span class="literal">NULL</span>) ObjectMonitor::_sync_Inflations-&gt;<span class="built_in">inc</span>() ;</span><br><span class="line">      <span class="built_in">TEVENT</span>(Inflate: overwrite neutral) ;</span><br><span class="line">      <span class="keyword">if</span> (TraceMonitorInflation) &#123;</span><br><span class="line">        <span class="keyword">if</span> (object-&gt;<span class="built_in">is_instance</span>()) &#123;</span><br><span class="line">          ResourceMark rm;</span><br><span class="line">          tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;Inflating object &quot;</span> INTPTR_FORMAT <span class="string">&quot; , mark &quot;</span> INTPTR_FORMAT <span class="string">&quot; , type %s&quot;</span>,</span><br><span class="line">            (<span class="keyword">void</span> *) object, (<span class="keyword">intptr_t</span>) object-&gt;<span class="built_in">mark</span>(),</span><br><span class="line">            object-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">external_name</span>());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 成功则返回 monitor </span></span><br><span class="line">      <span class="keyword">return</span> m ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inflated 状态的转换是在 markOopDesc::encode(m) 方法中</span></span><br><span class="line"><span class="comment"> * jdk/src/share/vm/oops/markOop.hpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> markOop <span class="title">encode</span><span class="params">(ObjectMonitor* monitor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">intptr_t</span> tmp = (<span class="keyword">intptr_t</span>) monitor;</span><br><span class="line">  <span class="comment">// monitor_value = 2（1 0）</span></span><br><span class="line">  <span class="keyword">return</span> (markOop) (tmp | monitor_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>锁的膨胀其实就是获取 ObjectMonitor 对象的过程，那么锁的竞争发生在什么地方呢？不知道大家是否还记得 inflate 方法调用的地方：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始膨胀</span></span><br><span class="line">ObjectSynchronizer::<span class="built_in">inflate</span>(THREAD, <span class="built_in">obj</span>())-&gt;<span class="built_in">enter</span>(THREAD);</span><br></pre></td></tr></table></figure>

<p>当 inflate 方法拿到 ObjectMonitor 对象之后，就会调用它的 enter 方法，ObjectMonitor::enter 方法就是锁竞争的核心方法了!</p>
<h2 id="enter"><a href="#enter" class="headerlink" title="enter"></a>enter</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在深入了解之前，需要先了解一下具体的操作理论，如：monitor 列表、线程驻留等。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1、如果线程通过 CAS 成功的将 monitor 字段 _owner 从 null 转换为 non-null，那么此线程便拥有了 monitor 的控制权。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2、不变性：任何时刻，一个线程只能出现在 monitor 列表 cxq、EntryList、WaitSet 中的一个。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3、参与竞争的线程通过 CAS 将自己 push 到 cxq 中并自旋/挂起。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 4、当线程得到锁之后，它必须从 cxq 或 EntryList 中出队。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 5、获取到锁的线程出队之前会标记以及唤醒 EntryList 中作为“假定继承人” 的后继线程。重要的是，该线程并不会取消后继线程与 EntryList 的链接。</span></span><br><span class="line"><span class="comment"> *    线程被唤醒之后会重新竞争 monitor 的控制权，它要不获取到锁要不重新挂起它自己。退出的线程并不会授权或传递控制权给它的后继线程。</span></span><br><span class="line"><span class="comment"> *    相反，退出的线程会释放控制权以及尽可能的唤醒后继线程，所以后继线程可以竞争（重新）锁的控制权。如果 EntryList 为空而 cxq 非空，退出线程会转移 cxq 到 EntryList 中。通过使用 CAS 置 null 来分离 cxq 将线程从 cxq 折叠到 EntryList 来实现。其中 EntryList 是双向链表而 cxq 是单向链表，这是由于基于 CAS 的 “push” 入队最近到达的线程来决定的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 6、并发不变性： </span></span><br><span class="line"><span class="comment"> *    1、只有 monitor 拥有者线程可以访问或者修改 EntryList。monitor 的互斥属性可以保护 EntryList 免于并发问题。</span></span><br><span class="line"><span class="comment"> *    2、只有 monitor 拥有者可以分离 cxq。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 7、monitor 列表（cxq、EntryList、WaitSet）的操作虽然避免了锁，但是它们并非是非锁的，除了入队。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 8、可以多个线程并发入队 cxq 但只允许一个线程分离，这个机制避免了 ABA 问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 9、总结起来就是，cxq 跟 EntryList 是由尝试获取锁的驻留线程组成的逻辑队列。通过这两个不同的队列来提高常量时间出队操作的概率以及降低链表末端的热度。关键一点就是降低 monitor 锁持有的时间。即使少量固定的自旋也能很大程度上降低 EntryList、cxq 上的入队出队次数进而减少内部锁及 monitor 元数据的竞争。</span></span><br><span class="line"><span class="comment"> *   cxq 保存着最近到达的线程并且由于是通过 CAS push 的操作，所以必须以单向链表的后进先出的顺序出队。当解锁线程发现 EntryList 为空而 _cxq 非空时，会在解锁时将 _cxq 转移到 EntryList。</span></span><br><span class="line"><span class="comment"> *   EntryList 按线性队列规则排序，它也可以被组织成双向链表或循环双向链表，便于我们可以在常量时间内进行插入、删除操作。队列在 exit() 调用时会强制调整，解锁线程会转移 cxq 到 EntryList，此时可以根据需要对 EntryList 中的线程进行排序以及重排序。</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * 10、monitor 同步子系统避免了使用除 park-unpark 平台相关的本地同步机制原语。也就是说 monitor 的实现仅仅依赖于原子化操作及 park-unpark。monitor 子系统管理所有的 RUNNING-&gt;BLOCKED、BLOCKED-&gt;READY 的转换而底层系统管理 RADY&lt;-&gt;RUN 的转换。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 11、wait() 方法会将调用者线程寄宿在 WaitSet 中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 12、notify()、notifyAll() 方法只是负责将线程从 WaitSet 转移到 EntryList 或者 cxq 中。notify() 唤醒被通知者的方式比较低效，被通知者可能只是简单的将自己刺入到通知者持有的锁中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> ATTR <span class="title">ObjectMonitor::enter</span><span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The following code is ordered to check the most common cases first</span></span><br><span class="line">  <span class="comment">// and to reduce RTS-&gt;RTO cache line upgrades on SPARC and IA32 processors.</span></span><br><span class="line">  Thread * <span class="keyword">const</span> Self = THREAD ;</span><br><span class="line">  <span class="keyword">void</span> * cur ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将当前线程设置为 monitor 的持有者</span></span><br><span class="line">  cur = Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_owner, <span class="literal">NULL</span>) ;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 说明设置 owner 成功</span></span><br><span class="line">  <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="comment">// Either ASSERT _recursions == 0 or explicitly set _recursions = 0.</span></span><br><span class="line">     <span class="built_in">assert</span> (_recursions == <span class="number">0</span>   , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="built_in">assert</span> (_owner      == Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="comment">// CONSIDER: set or assert OwnerIsThread == 1</span></span><br><span class="line">     <span class="comment">// 竞争锁成功，返回</span></span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是锁的重入</span></span><br><span class="line">  <span class="keyword">if</span> (cur == Self) &#123;</span><br><span class="line">     <span class="comment">// TODO-<span class="doctag">FIXME:</span> check for integer overflow!  BUGID 6557169.</span></span><br><span class="line">     <span class="comment">// 自增重入次数，然后返回</span></span><br><span class="line">     _recursions ++ ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前线程就是锁的持有者（cur 为基础锁对象而非线程）</span></span><br><span class="line">  <span class="keyword">if</span> (Self-&gt;<span class="built_in">is_lock_owned</span> ((address)cur)) &#123;</span><br><span class="line">    <span class="built_in">assert</span> (_recursions == <span class="number">0</span>, <span class="string">&quot;internal state error&quot;</span>);</span><br><span class="line">    <span class="comment">// 重入次数改为 1</span></span><br><span class="line">    _recursions = <span class="number">1</span> ;</span><br><span class="line">    <span class="comment">// Commute owner from a thread-specific on-stack BasicLockObject address to a full-fledged &quot;Thread *&quot;.</span></span><br><span class="line">    <span class="comment">// 将持有者改为当前线程</span></span><br><span class="line">    _owner = Self ;</span><br><span class="line">    <span class="comment">// 将持有者类型改为线程</span></span><br><span class="line">    OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 走到这里了，说明发生了竞争</span></span><br><span class="line">  <span class="built_in">assert</span> (Self-&gt;_Stalled == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  Self-&gt;_Stalled = <span class="built_in">intptr_t</span>(<span class="keyword">this</span>) ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队之前先进行一轮自旋</span></span><br><span class="line">  <span class="keyword">if</span> (Knob_SpinEarly &amp;&amp; <span class="built_in">TrySpin</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="built_in">assert</span> (_owner == Self      , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="built_in">assert</span> (_recursions == <span class="number">0</span>    , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="built_in">assert</span> (((oop)(<span class="built_in">object</span>()))-&gt;<span class="built_in">mark</span>() == markOopDesc::<span class="built_in">encode</span>(<span class="keyword">this</span>), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     Self-&gt;_Stalled = <span class="number">0</span> ;</span><br><span class="line">     <span class="comment">// 成功获取锁，返回</span></span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 持有者并非当前线程</span></span><br><span class="line">  <span class="built_in">assert</span> (_owner != Self          , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="comment">// 当前线程并非后继线程</span></span><br><span class="line">  <span class="built_in">assert</span> (_succ  != Self          , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="comment">// 属于 Java 线程</span></span><br><span class="line">  <span class="built_in">assert</span> (Self-&gt;<span class="built_in">is_Java_thread</span>()  , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="comment">// 转换为 Java 线程</span></span><br><span class="line">  JavaThread * jt = (JavaThread *) Self ;</span><br><span class="line">  <span class="comment">// 未处于安全点</span></span><br><span class="line">  <span class="built_in">assert</span> (!SafepointSynchronize::<span class="built_in">is_at_safepoint</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="comment">// 线程状态并未阻塞</span></span><br><span class="line">  <span class="built_in">assert</span> (jt-&gt;<span class="built_in">thread_state</span>() != _thread_blocked   , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="comment">// monitor 所属对象非空</span></span><br><span class="line">  <span class="built_in">assert</span> (<span class="keyword">this</span>-&gt;<span class="built_in">object</span>() != <span class="literal">NULL</span>  , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="comment">// cxq、EntryList 非空</span></span><br><span class="line">  <span class="built_in">assert</span> (_count &gt;= <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prevent deflation at STW-time.  See deflate_idle_monitors() and is_busy().</span></span><br><span class="line">  <span class="comment">// Ensure the object-monitor relationship remains stable while there&#x27;s contention.</span></span><br><span class="line">  <span class="comment">// 递增计数</span></span><br><span class="line">  Atomic::<span class="built_in">inc_ptr</span>(&amp;_count);</span><br><span class="line"></span><br><span class="line">  EventJavaMonitorEnter event;</span><br><span class="line"></span><br><span class="line">  &#123; <span class="comment">// 保存当前进程状态，同时将当前状态改为 BLOCKED_ON_MONITOR_ENTER</span></span><br><span class="line">    <span class="function">JavaThreadBlockedOnMonitorEnterState <span class="title">jtbmes</span><span class="params">(jt, <span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DTRACE_MONITOR_PROBE</span>(contended__enter, <span class="keyword">this</span>, <span class="built_in">object</span>(), jt);</span><br><span class="line">    <span class="keyword">if</span> (JvmtiExport::<span class="built_in">should_post_monitor_contended_enter</span>()) &#123;</span><br><span class="line">      JvmtiExport::<span class="built_in">post_monitor_contended_enter</span>(jt, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">OSThreadContendState <span class="title">osts</span><span class="params">(Self-&gt;osthread())</span></span>;</span><br><span class="line">    <span class="function">ThreadBlockInVM <span class="title">tbivm</span><span class="params">(jt)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程等待获取锁的 monitor 对象</span></span><br><span class="line">    Self-&gt;<span class="built_in">set_current_pending_monitor</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO-<span class="doctag">FIXME:</span> change the following for(;;) loop to straight-line code.</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      jt-&gt;<span class="built_in">set_suspend_equivalent</span>();</span><br><span class="line">      <span class="comment">// cleared by handle_special_suspend_equivalent_condition()</span></span><br><span class="line">      <span class="comment">// or java_suspend_self()</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 如果获取锁失败，那么需要通过自旋的方式等待锁释放</span></span><br><span class="line">      <span class="built_in">EnterI</span> (THREAD) ;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">ExitSuspendEquivalent</span>(jt)) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// We have acquired the contended monitor, but while we were</span></span><br><span class="line">      <span class="comment">// waiting another thread suspended us. We don&#x27;t want to enter</span></span><br><span class="line">      <span class="comment">// the monitor while suspended because that would surprise the</span></span><br><span class="line">      <span class="comment">// thread that suspended us.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      _recursions = <span class="number">0</span> ;</span><br><span class="line">      _succ = <span class="literal">NULL</span> ;</span><br><span class="line">      <span class="built_in">exit</span> (<span class="literal">false</span>, Self) ;</span><br><span class="line"></span><br><span class="line">      jt-&gt;<span class="built_in">java_suspend_self</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    Self-&gt;<span class="built_in">set_current_pending_monitor</span>(<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Atomic::<span class="built_in">dec_ptr</span>(&amp;_count);</span><br><span class="line">  <span class="built_in">assert</span> (_count &gt;= <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  Self-&gt;_Stalled = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Must either set _recursions = 0 or ASSERT _recursions == 0.</span></span><br><span class="line">  <span class="built_in">assert</span> (_recursions == <span class="number">0</span>     , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">assert</span> (_owner == Self       , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">assert</span> (_succ  != Self       , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">assert</span> (((oop)(<span class="built_in">object</span>()))-&gt;<span class="built_in">mark</span>() == markOopDesc::<span class="built_in">encode</span>(<span class="keyword">this</span>), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The thread -- now the owner -- is back in vm mode.</span></span><br><span class="line">  <span class="comment">// Report the glorious news via TI,DTrace and jvmstat.</span></span><br><span class="line">  <span class="comment">// The probe effect is non-trivial.  All the reportage occurs</span></span><br><span class="line">  <span class="comment">// while we hold the monitor, increasing the length of the critical</span></span><br><span class="line">  <span class="comment">// section.  Amdahl&#x27;s parallel speedup law comes vividly into play.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Another option might be to aggregate the events (thread local or</span></span><br><span class="line">  <span class="comment">// per-monitor aggregation) and defer reporting until a more opportune</span></span><br><span class="line">  <span class="comment">// time -- such as next time some thread encounters contention but has</span></span><br><span class="line">  <span class="comment">// yet to acquire the lock.  While spinning that thread could</span></span><br><span class="line">  <span class="comment">// spinning we could increment JVMStat counters, etc.</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">DTRACE_MONITOR_PROBE</span>(contended__entered, <span class="keyword">this</span>, <span class="built_in">object</span>(), jt);</span><br><span class="line">  <span class="keyword">if</span> (JvmtiExport::<span class="built_in">should_post_monitor_contended_entered</span>()) &#123;</span><br><span class="line">    JvmtiExport::<span class="built_in">post_monitor_contended_entered</span>(jt, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (event.<span class="built_in">should_commit</span>()) &#123;</span><br><span class="line">    event.<span class="built_in">set_klass</span>(((oop)<span class="keyword">this</span>-&gt;<span class="built_in">object</span>())-&gt;<span class="built_in">klass</span>());</span><br><span class="line">    event.<span class="built_in">set_previousOwner</span>((TYPE_JAVALANGTHREAD)_previous_owner_tid);</span><br><span class="line">    event.<span class="built_in">set_address</span>((TYPE_ADDRESS)(<span class="keyword">uintptr_t</span>)(<span class="keyword">this</span>-&gt;<span class="built_in">object_addr</span>()));</span><br><span class="line">    event.<span class="built_in">commit</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ObjectMonitor::_sync_ContendedLockAttempts != <span class="literal">NULL</span>) &#123;</span><br><span class="line">     ObjectMonitor::_sync_ContendedLockAttempts-&gt;<span class="built_in">inc</span>() ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><h3 id="enterI"><a href="#enterI" class="headerlink" title="enterI"></a>enterI</h3><blockquote>
<p>获取锁失败时，是通过 enterI 方法进行自旋等待锁释放。所以我们深入 enterI 看看具体的逻辑。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> ATTR <span class="title">ObjectMonitor::EnterI</span> <span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">    Thread * Self = THREAD ;</span><br><span class="line">    <span class="built_in">assert</span> (Self-&gt;<span class="built_in">is_Java_thread</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    <span class="built_in">assert</span> (((JavaThread *) Self)-&gt;<span class="built_in">thread_state</span>() == _thread_blocked   , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取一次锁，万一成了呢</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">TryLock</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">assert</span> (_succ != Self              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="built_in">assert</span> (_owner == Self             , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="built_in">assert</span> (_Responsible != Self       , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DeferredInitialize</span> () ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We try one round of spinning *before* enqueueing Self.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the _owner is ready but OFFPROC we could use a YieldTo()</span></span><br><span class="line">    <span class="comment">// operation to donate the remainder of this thread&#x27;s quantum</span></span><br><span class="line">    <span class="comment">// to the owner.  This has subtle but beneficial affinity</span></span><br><span class="line">    <span class="comment">// effects.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试一次自旋</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">TrySpin</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">assert</span> (_owner == Self        , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="built_in">assert</span> (_succ != Self         , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="built_in">assert</span> (_Responsible != Self  , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还是没有获取到锁，那么就需要入队挂起了</span></span><br><span class="line">    <span class="built_in">assert</span> (_succ  != Self            , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    <span class="built_in">assert</span> (_owner != Self            , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    <span class="built_in">assert</span> (_Responsible != Self      , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue &quot;Self&quot; on ObjectMonitor&#x27;s _cxq.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Node acts as a proxy for Self.</span></span><br><span class="line">    <span class="comment">// As an aside, if were to ever rewrite the synchronization code mostly</span></span><br><span class="line">    <span class="comment">// in Java, WaitNodes, ObjectMonitors, and Events would become 1st-class</span></span><br><span class="line">    <span class="comment">// Java objects.  This would avoid awkward lifecycle and liveness issues,</span></span><br><span class="line">    <span class="comment">// as well as eliminate a subset of ABA issues.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> eliminate ObjectWaiter and enqueue either Threads or Events.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前线程封装成 ObjectWaiter 对象</span></span><br><span class="line">    <span class="function">ObjectWaiter <span class="title">node</span><span class="params">(Self)</span> </span>;</span><br><span class="line">    Self-&gt;_ParkEvent-&gt;<span class="built_in">reset</span>() ;</span><br><span class="line">    node._prev   = (ObjectWaiter *) <span class="number">0xBAD</span> ;</span><br><span class="line">    node.TState  = ObjectWaiter::TS_CXQ ;</span><br><span class="line"></span><br><span class="line">    ObjectWaiter * nxt ;</span><br><span class="line">    <span class="comment">// 通过自旋的方式将线程存入 _cxq</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 采用头插法入队 _cxq：thread-2 -&gt; thread-1 -&gt; thread-0</span></span><br><span class="line">        node._next = nxt = _cxq ;</span><br><span class="line">        <span class="comment">// 存入成功则跳出循环，每次修改 _cxq 头结点为新入队节点</span></span><br><span class="line">        <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (&amp;node, &amp;_cxq, nxt) == nxt) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 _cxq 变更导致 CAS 失败，只需要重试就行了。当然，这可以再尝试获取锁一次</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">TryLock</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">assert</span> (_succ != Self         , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">            <span class="built_in">assert</span> (_owner == Self        , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">            <span class="built_in">assert</span> (_Responsible != Self  , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 尝试为 monitor 对象分配一个 “责任” 线程，如果竞争的线程都挂起了，那么即使 monitor 解锁了，也没有线程能获取到。</span></span><br><span class="line"><span class="comment">     * 所以需要有一个定时挂起的线程来负责检查并唤醒相应线程，该线程就是 “责任” 线程。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">16</span>) == <span class="number">0</span> &amp;&amp; nxt == <span class="literal">NULL</span> &amp;&amp; _EntryList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// Try to assume the role of responsible thread for the monitor.</span></span><br><span class="line">        <span class="comment">// CONSIDER:  ST vs CAS vs &#123; if (Responsible==null) Responsible=Self &#125;</span></span><br><span class="line">        Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_Responsible, <span class="literal">NULL</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The lock have been released while this thread was occupied queueing</span></span><br><span class="line">    <span class="comment">// itself onto _cxq.  To close the race and avoid &quot;stranding&quot; and</span></span><br><span class="line">    <span class="comment">// progress-liveness failure we must resample-retry _owner before parking.</span></span><br><span class="line">    <span class="comment">// Note the Dekker/Lamport duality: ST cxq; MEMBAR; LD Owner.</span></span><br><span class="line">    <span class="comment">// In this case the ST-MEMBAR is accomplished with CAS().</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Defer all thread state transitions until park-time.</span></span><br><span class="line">    <span class="comment">// Since state transitions are heavy and inefficient we&#x27;d like</span></span><br><span class="line">    <span class="comment">// to defer the state transitions until absolutely necessary,</span></span><br><span class="line">    <span class="comment">// and in doing so avoid some transitions ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">TEVENT</span> (Inflated enter - Contention) ;</span><br><span class="line">    <span class="keyword">int</span> nWakeups = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> RecheckInterval = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 拿到锁退出</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">TryLock</span> (Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        <span class="built_in">assert</span> (_owner != Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不存在 “责任” 线程时，设置 “责任” 线程</span></span><br><span class="line">        <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">2</span>) &amp;&amp; _Responsible == <span class="literal">NULL</span>) &#123;</span><br><span class="line">           Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_Responsible, <span class="literal">NULL</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前线程是 “责任” 线程，那么定时挂起当前线程，否则直接挂起</span></span><br><span class="line">        <span class="keyword">if</span> (_Responsible == Self || (SyncFlags &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">TEVENT</span> (Inflated enter - park TIMED) ;</span><br><span class="line">            Self-&gt;_ParkEvent-&gt;<span class="built_in">park</span> ((jlong) RecheckInterval) ;</span><br><span class="line">            <span class="comment">// Increase the RecheckInterval, but clamp the value.</span></span><br><span class="line">            RecheckInterval *= <span class="number">8</span> ;</span><br><span class="line">            <span class="keyword">if</span> (RecheckInterval &gt; <span class="number">1000</span>) RecheckInterval = <span class="number">1000</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">TEVENT</span> (Inflated enter - park UNTIMED) ;</span><br><span class="line">            Self-&gt;_ParkEvent-&gt;<span class="built_in">park</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">TryLock</span>(Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录无效的唤醒次数</span></span><br><span class="line">        <span class="built_in">TEVENT</span> (Inflated enter - Futile wakeup) ;</span><br><span class="line">        <span class="keyword">if</span> (ObjectMonitor::_sync_FutileWakeups != <span class="literal">NULL</span>) &#123;</span><br><span class="line">           ObjectMonitor::_sync_FutileWakeups-&gt;<span class="built_in">inc</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line">        ++ nWakeups ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assuming this is not a spurious wakeup we&#x27;ll normally find _succ == Self.</span></span><br><span class="line">        <span class="comment">// We can defer clearing _succ until after the spin completes</span></span><br><span class="line">        <span class="comment">// TrySpin() must tolerate being called with _succ == Self.</span></span><br><span class="line">        <span class="comment">// Try yet another round of adaptive spinning.</span></span><br><span class="line">        <span class="keyword">if</span> ((Knob_SpinAfterFutile &amp; <span class="number">1</span>) &amp;&amp; <span class="built_in">TrySpin</span> (Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can find that we were unpark()ed and redesignated _succ while</span></span><br><span class="line">        <span class="comment">// we were spinning.  That&#x27;s harmless.  If we iterate and call park(),</span></span><br><span class="line">        <span class="comment">// park() will consume the event and return immediately and we&#x27;ll</span></span><br><span class="line">        <span class="comment">// just spin again.  This pattern can repeat, leaving _succ to simply</span></span><br><span class="line">        <span class="comment">// spin on a CPU.  Enable Knob_ResetEvent to clear pending unparks().</span></span><br><span class="line">        <span class="comment">// Alternately, we can sample fired() here, and if set, forgo spinning</span></span><br><span class="line">        <span class="comment">// in the next iteration.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((Knob_ResetEvent &amp; <span class="number">1</span>) &amp;&amp; Self-&gt;_ParkEvent-&gt;<span class="built_in">fired</span>()) &#123;</span><br><span class="line">           Self-&gt;_ParkEvent-&gt;<span class="built_in">reset</span>() ;</span><br><span class="line">           OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_succ == Self) _succ = <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invariant: after clearing _succ a thread *must* retry _owner before parking.</span></span><br><span class="line">        OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 走到这里说明已经获取了锁</span></span><br><span class="line">    <span class="built_in">assert</span> (_owner == Self      , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    <span class="built_in">assert</span> (<span class="built_in">object</span>() != <span class="literal">NULL</span>    , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    <span class="comment">// I&#x27;d like to write:</span></span><br><span class="line">    <span class="comment">//   guarantee (((oop)(object()))-&gt;mark() == markOopDesc::encode(this), &quot;invariant&quot;) ;</span></span><br><span class="line">    <span class="comment">// but as we&#x27;re at a safepoint that&#x27;s not safe.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取到锁之后的取消链接</span></span><br><span class="line">    <span class="built_in">UnlinkAfterAcquire</span> (Self, &amp;node) ;</span><br><span class="line">    <span class="comment">// 如果后继线程是当前线程，将后继线程置 null</span></span><br><span class="line">    <span class="keyword">if</span> (_succ == Self) _succ = <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span> (_succ != Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    <span class="comment">// 如果当前线程是 “责任” 线程</span></span><br><span class="line">    <span class="keyword">if</span> (_Responsible == Self) &#123;</span><br><span class="line">        <span class="comment">// “责任” 线程置 null</span></span><br><span class="line">        _Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">        OrderAccess::<span class="built_in">fence</span>(); <span class="comment">// Dekker pivot-point</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We may leave threads on cxq|EntryList without a designated</span></span><br><span class="line">        <span class="comment">// &quot;Responsible&quot; thread.  This is benign.  When this thread subsequently</span></span><br><span class="line">        <span class="comment">// exits the monitor it can &quot;see&quot; such preexisting &quot;old&quot; threads --</span></span><br><span class="line">        <span class="comment">// threads that arrived on the cxq|EntryList before the fence, above --</span></span><br><span class="line">        <span class="comment">// by LDing cxq|EntryList.  Newly arrived threads -- that is, threads</span></span><br><span class="line">        <span class="comment">// that arrive on cxq after the ST:MEMBAR, above -- will set Responsible</span></span><br><span class="line">        <span class="comment">// non-null and elect a new &quot;Responsible&quot; timer thread.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// This thread executes:</span></span><br><span class="line">        <span class="comment">//    ST Responsible=null; MEMBAR    (in enter epilog - here)</span></span><br><span class="line">        <span class="comment">//    LD cxq|EntryList               (in subsequent exit)</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Entering threads in the slow/contended path execute:</span></span><br><span class="line">        <span class="comment">//    ST cxq=nonnull; MEMBAR; LD Responsible (in enter prolog)</span></span><br><span class="line">        <span class="comment">//    The (ST cxq; MEMBAR) is accomplished with CAS().</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// The MEMBAR, above, prevents the LD of cxq|EntryList in the subsequent</span></span><br><span class="line">        <span class="comment">// exit operation from floating above the ST Responsible=null.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We&#x27;ve acquired ownership with CAS().</span></span><br><span class="line">    <span class="comment">// CAS is serializing -- it has MEMBAR/FENCE-equivalent semantics.</span></span><br><span class="line">    <span class="comment">// But since the CAS() this thread may have also stored into _succ,</span></span><br><span class="line">    <span class="comment">// EntryList, cxq or Responsible.  These meta-data updates must be</span></span><br><span class="line">    <span class="comment">// visible __before this thread subsequently drops the lock.</span></span><br><span class="line">    <span class="comment">// Consider what could occur if we didn&#x27;t enforce this constraint --</span></span><br><span class="line">    <span class="comment">// STs to monitor meta-data and user-data could reorder with (become</span></span><br><span class="line">    <span class="comment">// visible after) the ST in exit that drops ownership of the lock.</span></span><br><span class="line">    <span class="comment">// Some other thread could then acquire the lock, but observe inconsistent</span></span><br><span class="line">    <span class="comment">// or old monitor meta-data and heap data.  That violates the JMM.</span></span><br><span class="line">    <span class="comment">// To that end, the 1-0 exit() operation must have at least STST|LDST</span></span><br><span class="line">    <span class="comment">// &quot;release&quot; barrier semantics.  Specifically, there must be at least a</span></span><br><span class="line">    <span class="comment">// STST|LDST barrier in exit() before the ST of null into _owner that drops</span></span><br><span class="line">    <span class="comment">// the lock.   The barrier ensures that changes to monitor meta-data and data</span></span><br><span class="line">    <span class="comment">// protected by the lock will be visible before we release the lock, and</span></span><br><span class="line">    <span class="comment">// therefore before some other thread (CPU) has a chance to acquire the lock.</span></span><br><span class="line">    <span class="comment">// See also: http://gee.cs.oswego.edu/dl/jmm/cookbook.html.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Critically, any prior STs to _succ or EntryList must be visible before</span></span><br><span class="line">    <span class="comment">// the ST of null into _owner in the *subsequent* (following) corresponding</span></span><br><span class="line">    <span class="comment">// monitorexit.  Recall too, that in 1-0 mode monitorexit does not necessarily</span></span><br><span class="line">    <span class="comment">// execute a serializing instruction.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SyncFlags &amp; <span class="number">8</span>) &#123;</span><br><span class="line">       OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock"></a>tryLock</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Caveat: TryLock() is not necessarily serializing if it returns failure.</span></span><br><span class="line"><span class="comment">// Callers must compensate as needed.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ObjectMonitor::TryLock</span> <span class="params">(Thread * Self)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// monitor 当前的持有者</span></span><br><span class="line">      <span class="keyword">void</span> * own = _owner ;</span><br><span class="line">      <span class="comment">// 如果不为 null，说明已经有归属，那么上锁肯定失败</span></span><br><span class="line">      <span class="keyword">if</span> (own != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">      <span class="comment">// 如果 CAS 成功，说明获取到了锁</span></span><br><span class="line">      <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_owner, <span class="literal">NULL</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="comment">// 重复次数肯定为 0，毕竟刚获得锁</span></span><br><span class="line">         <span class="built_in">assert</span> (_recursions == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">         <span class="comment">// 持有者是否为自己</span></span><br><span class="line">         <span class="built_in">assert</span> (_owner == Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">         <span class="comment">// 说明上锁成功了</span></span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 上锁失败</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>enter 方法主要做了以下几件事：</li>
<li>通过 CAS 操作，将当前线程设置到 monitor 对象的 _owner 字段中以获取锁，成功则返回。</li>
<li>如果 _owner 指向的就是当前线程，说明发生了锁重入，递增 _recursions。</li>
<li>如果当前线程获取锁成功，那么就将 _recursions 设置为 1，同时 _owner 指向当前线程。</li>
<li>如果失败，需要等待锁的释放。</li>
</ul>
<p>如果获取锁失败，那么就需要通过自旋的方式等待锁的释放，也就是 enterI 方法要做的事：</p>
<ul>
<li>将当前线程封装成状态为 TS_CXQ 的 ObjectWaiter。</li>
<li>通过自旋操作将 ObjectWaiter 节点 push 到 _cxq 队列中。</li>
<li>进入到 _cxq 队列中的节点继续通过自旋的方式尝试获取锁，如果达到指定阈值还未成功，则通过 park 将自己挂起等待被唤醒。</li>
</ul>
</li>
</ul>
<h1 id="锁的释放"><a href="#锁的释放" class="headerlink" title="锁的释放"></a>锁的释放</h1><h2 id="轻量级锁的释放"><a href="#轻量级锁的释放" class="headerlink" title="轻量级锁的释放"></a>轻量级锁的释放</h2><blockquote>
<p>轻量级锁的释放是通过 monitorexit 调用完成的。</p>
</blockquote>
<h3 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// monitorexit 指令定义</span></span><br><span class="line"><span class="built_in">IRT_ENTRY_NO_ASYNC</span>(<span class="keyword">void</span>, InterpreterRuntime::<span class="built_in">monitorexit</span>(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;<span class="built_in">last_frame</span>().<span class="built_in">interpreter_frame_verify_monitor</span>(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj())</span></span>;</span><br><span class="line">  <span class="built_in">assert</span>(Universe::<span class="built_in">heap</span>()-&gt;<span class="built_in">is_in_reserved_or_null</span>(<span class="built_in">h_obj</span>()),</span><br><span class="line">         <span class="string">&quot;must be NULL or an object&quot;</span>);</span><br><span class="line">  <span class="comment">// 先判断当前的锁状态</span></span><br><span class="line">  <span class="keyword">if</span> (elem == <span class="literal">NULL</span> || <span class="built_in">h_obj</span>()-&gt;<span class="built_in">is_unlocked</span>()) &#123;</span><br><span class="line">    <span class="built_in">THROW</span>(vmSymbols::<span class="built_in">java_lang_IllegalMonitorStateException</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 释放锁</span></span><br><span class="line">  ObjectSynchronizer::<span class="built_in">slow_exit</span>(<span class="built_in">h_obj</span>(), elem-&gt;<span class="built_in">lock</span>(), thread);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Free entry. This must be done here, since a pending exception might be installed on</span></span><br><span class="line">  <span class="comment">// exit. If it is not cleared, the exception handling code will try to unlock the monitor again.</span></span><br><span class="line">  <span class="comment">// 将锁指向的目标对象设置为 null</span></span><br><span class="line">  elem-&gt;<span class="built_in">set_obj</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;<span class="built_in">last_frame</span>().<span class="built_in">interpreter_frame_verify_monitor</span>(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">IRT_END</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="slow-exit"><a href="#slow-exit" class="headerlink" title="slow_exit"></a>slow_exit</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由 fast_exit 完成锁的释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::slow_exit</span><span class="params">(oop object, BasicLock* lock, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fast_exit</span> (object, lock, THREAD) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fast-exit"><a href="#fast-exit" class="headerlink" title="fast_exit"></a>fast_exit</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::fast_exit</span><span class="params">(oop object, BasicLock* lock, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 锁状态不能处于偏移模式</span></span><br><span class="line">  <span class="built_in">assert</span>(!object-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;should not see bias pattern here&quot;</span>);</span><br><span class="line">  <span class="comment">// if displaced header is null, the previous enter is recursive enter, no-op</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取锁中的 displaced_header 用于还原 markWord</span></span><br><span class="line">  markOop dhw = lock-&gt;<span class="built_in">displaced_header</span>();</span><br><span class="line">  markOop mark ;</span><br><span class="line">  <span class="comment">// 如果为 null，说明前一个锁的进入是重入的，除了校验之外无需做任何操作</span></span><br><span class="line">  <span class="keyword">if</span> (dhw == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="comment">// Recursive stack-lock.</span></span><br><span class="line">     <span class="comment">// Diagnostics -- Could be: stack-locked, inflating, inflated.</span></span><br><span class="line">     <span class="comment">// 去对象中的 markWord</span></span><br><span class="line">     mark = object-&gt;<span class="built_in">mark</span>() ;</span><br><span class="line">     <span class="comment">// 有锁状态</span></span><br><span class="line">     <span class="built_in">assert</span> (!mark-&gt;<span class="built_in">is_neutral</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="comment">// 轻量级锁并且并非处于膨胀中状态，那么当前线程必须为锁的持有者</span></span><br><span class="line">     <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_locker</span>() &amp;&amp; mark != markOopDesc::<span class="built_in">INFLATING</span>()) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(THREAD-&gt;<span class="built_in">is_lock_owned</span>((address)mark-&gt;<span class="built_in">locker</span>()), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 重量级锁</span></span><br><span class="line">     <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_monitor</span>()) &#123;</span><br><span class="line">        ObjectMonitor * m = mark-&gt;<span class="built_in">monitor</span>() ;</span><br><span class="line">        <span class="built_in">assert</span>(((oop)(m-&gt;<span class="built_in">object</span>()))-&gt;<span class="built_in">mark</span>() == mark, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="built_in">assert</span>(m-&gt;<span class="built_in">is_entered</span>(THREAD), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 非锁重入，那么取 markWord</span></span><br><span class="line">  mark = object-&gt;<span class="built_in">mark</span>() ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是轻量级锁，那么只需用 displaced_header 替换回 markWord 即可</span></span><br><span class="line">  <span class="keyword">if</span> (mark == (markOop) lock) &#123;</span><br><span class="line">     <span class="built_in">assert</span> (dhw-&gt;<span class="built_in">is_neutral</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="keyword">if</span> ((markOop) Atomic::<span class="built_in">cmpxchg_ptr</span> (dhw, object-&gt;<span class="built_in">mark_addr</span>(), mark) == mark) &#123;</span><br><span class="line">        <span class="built_in">TEVENT</span> (fast_exit: release stacklock) ;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 替换失败升级为重量级锁</span></span><br><span class="line">  ObjectSynchronizer::<span class="built_in">inflate</span>(THREAD, object)-&gt;<span class="built_in">exit</span> (<span class="literal">true</span>, THREAD) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>轻量级锁的释放很简单，只是将当前线程栈中锁记录的 displaced_header 头替换回对象 markWord 即可。如果替换失败，那么需要膨胀成重量级锁，实现重量级锁的释放逻辑。</p>
<h2 id="重量级锁的释放"><a href="#重量级锁的释放" class="headerlink" title="重量级锁的释放"></a>重量级锁的释放</h2><blockquote>
<p>重量级锁的释放由 ObjectMonitor::exit 方法来实现。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> ATTR <span class="title">ObjectMonitor::exit</span><span class="params">(<span class="keyword">bool</span> not_suspended, TRAPS)</span> </span>&#123;</span><br><span class="line">   Thread * Self = THREAD ;</span><br><span class="line">   <span class="comment">// 当前 _owner 未指向当前线程</span></span><br><span class="line">   <span class="keyword">if</span> (THREAD != _owner) &#123;</span><br><span class="line">     <span class="comment">// 如果 _owner 指向了当前线程的栈锁</span></span><br><span class="line">     <span class="keyword">if</span> (THREAD-&gt;<span class="built_in">is_lock_owned</span>((address) _owner)) &#123;</span><br><span class="line">       <span class="comment">// 该场景下肯定未发生重入（因为重入的时候会进行栈锁到线程的替换）</span></span><br><span class="line">       <span class="built_in">assert</span> (_recursions == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">       <span class="comment">// 将栈锁替换为线程</span></span><br><span class="line">       _owner = THREAD ;</span><br><span class="line">       <span class="comment">// 重入次数为 0 </span></span><br><span class="line">       _recursions = <span class="number">0</span> ;</span><br><span class="line">       <span class="comment">// owner 指向的类型改为线程</span></span><br><span class="line">       OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// <span class="doctag">NOTE:</span> we need to handle unbalanced monitor enter/exit</span></span><br><span class="line">       <span class="comment">// in native code by throwing an exception.</span></span><br><span class="line">       <span class="comment">// <span class="doctag">TODO:</span> Throw an IllegalMonitorStateException ?</span></span><br><span class="line">       <span class="built_in">TEVENT</span> (Exit - Throw IMSX) ;</span><br><span class="line">       <span class="built_in">assert</span>(<span class="literal">false</span>, <span class="string">&quot;Non-balanced monitor enter/exit!&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">          <span class="built_in">THROW</span>(vmSymbols::<span class="built_in">java_lang_IllegalMonitorStateException</span>());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果发生了锁的重入</span></span><br><span class="line">   <span class="keyword">if</span> (_recursions != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 递减次数，然后返回</span></span><br><span class="line">     _recursions--;       </span><br><span class="line">     <span class="built_in">TEVENT</span> (Inflated exit - recursive) ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Invariant: after setting Responsible=null an thread must execute</span></span><br><span class="line">   <span class="comment">// a MEMBAR or other serializing instruction before fetching EntryList|cxq.</span></span><br><span class="line">   <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// “责任” 线程置 null</span></span><br><span class="line">      _Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> INCLUDE_TRACE</span></span><br><span class="line">   <span class="comment">// get the owner&#x27;s thread id for the MonitorEnter event</span></span><br><span class="line">   <span class="comment">// if it is enabled and the thread isn&#x27;t suspended</span></span><br><span class="line">   <span class="keyword">if</span> (not_suspended &amp;&amp; Tracing::<span class="built_in">is_event_enabled</span>(TraceJavaMonitorEnterEvent)) &#123;</span><br><span class="line">     _previous_owner_tid = SharedRuntime::<span class="built_in">get_java_tid</span>(Self);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 释放锁的线程为当前锁的持有者</span></span><br><span class="line">      <span class="built_in">assert</span> (THREAD == _owner, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (Knob_ExitPolicy == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 释放锁，将 _owner 置为 null</span></span><br><span class="line">         OrderAccess::<span class="built_in">release_store_ptr</span> (&amp;_owner, <span class="literal">NULL</span>) ;</span><br><span class="line">         <span class="comment">// 写读屏障</span></span><br><span class="line">         OrderAccess::<span class="built_in">storeload</span>() ;                         <span class="comment">// See if we need to wake a successor</span></span><br><span class="line">         <span class="keyword">if</span> ((<span class="built_in">intptr_t</span>(_EntryList)|<span class="built_in">intptr_t</span>(_cxq)) == <span class="number">0</span> || _succ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">TEVENT</span> (Inflated exit - simple egress) ;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">TEVENT</span> (Inflated exit - complex egress) ;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * 通常退出的线程负责确保后继线程，但是如果其他的后继线程已经就绪或者</span></span><br><span class="line"><span class="comment">          * 其他进入的线程都在自旋，那么当前线程可以简单地将 _owner 置为 null </span></span><br><span class="line"><span class="comment">          * 而不用唤醒后继线程。“责任” 也会转移到已经就绪后者正在运行的后继线程。</span></span><br><span class="line"><span class="comment">          *</span></span><br><span class="line"><span class="comment">          * 变量 _succ 表示后继线程已经唤醒但还未运行，它对减少无效的唤醒频率至关重要。</span></span><br><span class="line"><span class="comment">          * Enter() 中的自旋线程可以将 _succ 设置为非 null，在当前实现中，自旋</span></span><br><span class="line"><span class="comment">          * 线程通过设置 _succ 使得退出线程避免唤醒后继线程（当然还有另外一种</span></span><br><span class="line"><span class="comment">          * 方案是，退出线程释放锁后在通过短暂自旋以查看是否有自旋线程在尝试获取锁</span></span><br><span class="line"><span class="comment">          * 如果是，退出线程可以迅速退出而免于唤醒后继线程，否则就需要出队并唤醒一个后继。注意，我们需要缩短 post-drop 的自旋时间但是不能短于最坏情况下的往返缓存行迁移时间。</span></span><br><span class="line"><span class="comment">          * 释放的锁需要对自旋者可见，自旋者获取的锁也必须对退出的线程可见。</span></span><br><span class="line"><span class="comment">          * </span></span><br><span class="line"><span class="comment">          * 只有锁的持有者才能变更 EntryList 或者转移 _cxq，如果获取锁失败，</span></span><br><span class="line"><span class="comment">          * 那么确保后继线程的责任就落实到后续的新持有者了。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (THREAD, &amp;_owner, <span class="literal">NULL</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">TEVENT</span> (Exit - Reacquired) ;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> ((<span class="built_in">intptr_t</span>(_EntryList)|<span class="built_in">intptr_t</span>(_cxq)) == <span class="number">0</span> || _succ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            OrderAccess::<span class="built_in">release_store_ptr</span> (&amp;_owner, <span class="literal">NULL</span>) ;   <span class="comment">// drop the lock</span></span><br><span class="line">            OrderAccess::<span class="built_in">storeload</span>() ;</span><br><span class="line">            <span class="comment">// Ratify the previously observed values.</span></span><br><span class="line">            <span class="keyword">if</span> (_cxq == <span class="literal">NULL</span> || _succ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">TEVENT</span> (Inflated exit - simple egress) ;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 如果处于快速退出的线程与慢进入的线程发生了竞争，那么有以下两种选择：</span></span><br><span class="line"><span class="comment">             * A. 尝试重新获取锁。</span></span><br><span class="line"><span class="comment">             *    如果 CAS 失败并立即返回，那么要不重启/新执行退出操作要不执行</span></span><br><span class="line"><span class="comment">             *    以下唤醒后继线程的代码。</span></span><br><span class="line"><span class="comment">             * B. 如果构成 EntryList/cxq 的元素是 TSM，那么我们可以简单的唤醒</span></span><br><span class="line"><span class="comment">             *    一个引导线程而无需设置 _succ。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (THREAD, &amp;_owner, <span class="literal">NULL</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">               <span class="built_in">TEVENT</span> (Inflated exit - reacquired succeeded) ;</span><br><span class="line">               <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">TEVENT</span> (Inflated exit - reacquired failed) ;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">TEVENT</span> (Inflated exit - complex egress) ;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">guarantee</span> (_owner == THREAD, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">      ObjectWaiter * w = <span class="literal">NULL</span> ;</span><br><span class="line">      <span class="keyword">int</span> QMode = Knob_QMode ;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">2</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">// QMode == 2 : cxq 优先于 EntryList.</span></span><br><span class="line">          <span class="comment">// 尝试直接唤醒 cxq 中的后继线程，如果成功，后继线程需要从 cxq 中解绑。</span></span><br><span class="line">          w = _cxq ;</span><br><span class="line">          <span class="built_in">assert</span> (w != <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          <span class="built_in">assert</span> (w-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">          <span class="comment">// 唤醒节点</span></span><br><span class="line">          <span class="built_in">ExitEpilog</span> (Self, w) ;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">3</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">// 将 cxq 转移到 EntryList 中</span></span><br><span class="line">          w = _cxq ;</span><br><span class="line">          <span class="comment">// 将 cxq 中的元素置空</span></span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             <span class="built_in">assert</span> (w != <span class="literal">NULL</span>, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">             ObjectWaiter * u = (ObjectWaiter *) Atomic::<span class="built_in">cmpxchg_ptr</span> (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">             <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">             w = u ;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">assert</span> (w != <span class="literal">NULL</span>              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">          ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">          ObjectWaiter * p ;</span><br><span class="line">          <span class="comment">// 变更状态</span></span><br><span class="line">          <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">              <span class="built_in">guarantee</span> (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">              p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">              p-&gt;_prev = q ;</span><br><span class="line">              q = p ;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">          ObjectWaiter * Tail ;</span><br><span class="line">          <span class="comment">// 找到 EntryList 的尾节点</span></span><br><span class="line">          <span class="keyword">for</span> (Tail = _EntryList ; Tail != <span class="literal">NULL</span> &amp;&amp; Tail-&gt;_next != <span class="literal">NULL</span> ; Tail = Tail-&gt;_next) ;</span><br><span class="line">          <span class="keyword">if</span> (Tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">              _EntryList = w ;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 双向指针，将 _cxq 中的元素追加到 EntryList 的尾部</span></span><br><span class="line">              Tail-&gt;_next = w ;</span><br><span class="line">              w-&gt;_prev = Tail ;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Fall thru into code that tries to wake a successor from EntryList</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">4</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          w = _cxq ;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             <span class="built_in">assert</span> (w != <span class="literal">NULL</span>, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">             ObjectWaiter * u = (ObjectWaiter *) Atomic::<span class="built_in">cmpxchg_ptr</span> (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">             <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">             w = u ;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">assert</span> (w != <span class="literal">NULL</span>              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">          ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">          ObjectWaiter * p ;</span><br><span class="line">          <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">              <span class="built_in">guarantee</span> (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">              p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">              p-&gt;_prev = q ;</span><br><span class="line">              q = p ;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 将 EntryList 追加到 _cxq 的尾部</span></span><br><span class="line">          <span class="keyword">if</span> (_EntryList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">              q-&gt;_next = _EntryList ;</span><br><span class="line">              _EntryList-&gt;_prev = q ;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 将 EntryList 头指针指向 cxq 头部元素，也就是说 EntryList 头部元素是最新运行的线程</span></span><br><span class="line">          _EntryList = w ;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Fall thru into code that tries to wake a successor from EntryList</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      w = _EntryList  ;</span><br><span class="line">      <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">// I&#x27;d like to write: guarantee (w-&gt;_thread != Self).</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * 实践中，正在退出的线程也可能出现在 EntryList 中。当线程 T1 调用</span></span><br><span class="line"><span class="comment">           * 0.wait() 时，会将 T1 入队到 0 的 waitset 中，接着调用 exit() </span></span><br><span class="line"><span class="comment">           * 通过将 0._owner 设置为 null 来释放锁。T2 获取到了 0 并且调用</span></span><br><span class="line"><span class="comment">           * 0.notify()，此时 T1 就会从 0 的 waitset 转移到 0 的 EntryList</span></span><br><span class="line"><span class="comment">           * 中。T2 就会释放锁，将 _owner 设置为 null，此时 T2 注意到</span></span><br><span class="line"><span class="comment">           * EntryList 已经被填充，那么处于 EntryList 中的 T1 就会重新申请锁，</span></span><br><span class="line"><span class="comment">           * 但是此时它发现它就处于 EntryList 中。</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">           <span class="comment">// 鉴于此，我们不得不考虑 w 与 self 关联的情况。</span></span><br><span class="line">          <span class="built_in">assert</span> (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          <span class="comment">// 唤醒节点</span></span><br><span class="line">          <span class="built_in">ExitEpilog</span> (Self, w) ;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// EntryList 为空，此时查看 _cxq 是否也为空，如果如此，那么继续执行循环</span></span><br><span class="line">      w = _cxq ;</span><br><span class="line">      <span class="keyword">if</span> (w == <span class="literal">NULL</span>) <span class="keyword">continue</span> ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// _cxq 不为空，那么将 _cxq 置空</span></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="built_in">assert</span> (w != <span class="literal">NULL</span>, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">          ObjectWaiter * u = (ObjectWaiter *) Atomic::<span class="built_in">cmpxchg_ptr</span> (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">          <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">          w = u ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">TEVENT</span> (Inflated exit - drain cxq into EntryList) ;</span><br><span class="line">      <span class="comment">// 此时 w 肯定是不为空的，它指向了原 _cxq 队列</span></span><br><span class="line">      <span class="built_in">assert</span> (w != <span class="literal">NULL</span>              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">      <span class="comment">// EntryList 肯定为空</span></span><br><span class="line">      <span class="built_in">assert</span> (_EntryList  == <span class="literal">NULL</span>    , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Convert the LIFO SLL anchored by _cxq into a DLL.</span></span><br><span class="line">      <span class="comment">// The list reorganization step operates in O(LENGTH(w)) time.</span></span><br><span class="line">      <span class="comment">// It&#x27;s critical that this step operate quickly as</span></span><br><span class="line">      <span class="comment">// &quot;Self&quot; still holds the outer-lock, restricting parallelism</span></span><br><span class="line">      <span class="comment">// and effectively lengthening the critical section.</span></span><br><span class="line">      <span class="comment">// Invariant: s chases t chases u.</span></span><br><span class="line">      <span class="comment">// TODO-<span class="doctag">FIXME:</span> consider changing EntryList from a DLL to a CDLL so</span></span><br><span class="line">      <span class="comment">// we have faster access to the tail.</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="comment">// QMode == 1 : 将 cxq 转移至 EntryList，并对集合中的元素进行反转</span></span><br><span class="line">         ObjectWaiter * s = <span class="literal">NULL</span> ;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          *  thread-2 -&gt; thread-1 -&gt; thread-0 (_cxq，后进先出)</span></span><br><span class="line"><span class="comment">          *   w  t</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         ObjectWaiter * t = w ;</span><br><span class="line">         ObjectWaiter * u = <span class="literal">NULL</span> ;</span><br><span class="line">         <span class="keyword">while</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">             <span class="comment">// 当前 w 指向的元素状态必须为 TS_CXQ</span></span><br><span class="line">             <span class="built_in">guarantee</span> (t-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">             t-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">             u = t-&gt;_next ;</span><br><span class="line">             t-&gt;_prev = u ;</span><br><span class="line">             t-&gt;_next = s ;</span><br><span class="line">             s = t;</span><br><span class="line">             t = u ;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * thread-0 &lt;-&gt; thread-1 &lt;-&gt; thread-2</span></span><br><span class="line"><span class="comment">          *   s</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         _EntryList  = s ;</span><br><span class="line">         <span class="built_in">assert</span> (s != <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// QMode == 0 or QMode == 2</span></span><br><span class="line">         _EntryList = w ;</span><br><span class="line">         ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">         ObjectWaiter * p ;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * thread-2 &lt;-&gt; thread-1 &lt;-&gt; thread-0</span></span><br><span class="line"><span class="comment">          * EntryList</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">             <span class="built_in">guarantee</span> (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">             p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">             <span class="comment">// 变成双链表</span></span><br><span class="line">             p-&gt;_prev = q ;</span><br><span class="line">             q = p ;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// In 1-0 mode we need: ST EntryList; MEMBAR #storestore; ST _owner = NULL</span></span><br><span class="line">      <span class="comment">// The MEMBAR is satisfied by the release_store() operation in ExitEpilog().</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// See if we can abdicate to a spinner instead of waking a thread.</span></span><br><span class="line">      <span class="comment">// A primary goal of the implementation is to reduce the</span></span><br><span class="line">      <span class="comment">// context-switch rate.</span></span><br><span class="line">      <span class="keyword">if</span> (_succ != <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      w = _EntryList  ;</span><br><span class="line">      <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">// 状态校验</span></span><br><span class="line">          <span class="built_in">guarantee</span> (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          <span class="comment">// 唤醒节点</span></span><br><span class="line">          <span class="built_in">ExitEpilog</span> (Self, w) ;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ExitEpilog"><a href="#ExitEpilog" class="headerlink" title="ExitEpilog"></a>ExitEpilog</h3><blockquote>
<p>ExitEpilog 负责节点的唤醒。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectMonitor::ExitEpilog</span> <span class="params">(Thread * Self, ObjectWaiter * Wakee)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 持有者必须为释放锁的线程</span></span><br><span class="line">   <span class="built_in">assert</span> (_owner == Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 大体流程：</span></span><br><span class="line">   <span class="comment">// 1. ST _succ = wakee</span></span><br><span class="line">   <span class="comment">// 2. membar #loadstore|#storestore;</span></span><br><span class="line">   <span class="comment">// 2. ST _owner = NULL</span></span><br><span class="line">   <span class="comment">// 3. unpark(wakee)</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 如果后继功能开启，那么将 _succ 指向等待唤醒的节点线程</span></span><br><span class="line">   _succ = Knob_SuccEnabled ? Wakee-&gt;_thread : <span class="literal">NULL</span> ;</span><br><span class="line">   ParkEvent * Trigger = Wakee-&gt;_event ;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Hygiene -- once we&#x27;ve set _owner = NULL we can&#x27;t safely dereference Wakee again.</span></span><br><span class="line">   <span class="comment">// The thread associated with Wakee may have grabbed the lock and &quot;Wakee&quot; may be</span></span><br><span class="line">   <span class="comment">// out-of-scope (non-extant).</span></span><br><span class="line">   Wakee  = <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 释放锁</span></span><br><span class="line">   OrderAccess::<span class="built_in">release_store_ptr</span> (&amp;_owner, <span class="literal">NULL</span>) ;</span><br><span class="line">   OrderAccess::<span class="built_in">fence</span>() ;                               <span class="comment">// ST _owner vs LD in unpark()</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (SafepointSynchronize::<span class="built_in">do_call_back</span>()) &#123;</span><br><span class="line">      <span class="built_in">TEVENT</span> (unpark before SAFEPOINT) ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">DTRACE_MONITOR_PROBE</span>(contended__exit, <span class="keyword">this</span>, <span class="built_in">object</span>(), Self);</span><br><span class="line">   <span class="comment">// 唤醒线程</span></span><br><span class="line">   Trigger-&gt;<span class="built_in">unpark</span>() ;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Maintain stats and report events to JVMTI</span></span><br><span class="line">   <span class="keyword">if</span> (ObjectMonitor::_sync_Parks != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      ObjectMonitor::_sync_Parks-&gt;<span class="built_in">inc</span>() ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/articles/tags/Java/" rel="tag"># Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/articles/2023/03/23/java/Java%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8BSynchronized%E5%AE%9E%E7%8E%B0(%E4%B8%8A)/" rel="prev" title="Java 锁机制之 Synchronized 实现（上）">
      <i class="fa fa-chevron-left"></i> Java 锁机制之 Synchronized 实现（上）
    </a></div>
      <div class="post-nav-item">
    <a href="/articles/2023/04/11/java/Java%E9%94%81%E6%9C%BA%E5%88%B6(%E4%B8%8A)%E4%B9%8BCAS/" rel="next" title="Java 锁机制（上）之 CAS">
      Java 锁机制（上）之 CAS <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">2.</span> <span class="nav-text">轻量级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-markWord-%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">轻量级锁 markWord 结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LockRecord"><span class="nav-number">2.1.1.</span> <span class="nav-text">LockRecord</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#slow-enter"><span class="nav-number">2.2.</span> <span class="nav-text">slow_enter</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">3.</span> <span class="nav-text">重量级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#monitor-%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.1.</span> <span class="nav-text">monitor 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#inflate"><span class="nav-number">3.2.</span> <span class="nav-text">inflate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#enter"><span class="nav-number">3.3.</span> <span class="nav-text">enter</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#enterI"><span class="nav-number">3.3.1.</span> <span class="nav-text">enterI</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tryLock"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">tryLock</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE"><span class="nav-number">4.</span> <span class="nav-text">锁的释放</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE"><span class="nav-number">4.1.</span> <span class="nav-text">轻量级锁的释放</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#monitorexit"><span class="nav-number">4.1.1.</span> <span class="nav-text">monitorexit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slow-exit"><span class="nav-number">4.1.2.</span> <span class="nav-text">slow_exit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fast-exit"><span class="nav-number">4.1.3.</span> <span class="nav-text">fast_exit</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE"><span class="nav-number">4.2.</span> <span class="nav-text">重量级锁的释放</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ExitEpilog"><span class="nav-number">4.2.1.</span> <span class="nav-text">ExitEpilog</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Tubetrue01"
      src="/articles/img/head.PNG">
  <p class="site-author-name" itemprop="name">Tubetrue01</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/articles/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/articles/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Tubetrue01" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Tubetrue01" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/articles/Tubetrue01@gmail.com" title="E-Mail → Tubetrue01@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tubetrue01</span>
</div>



        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/articles/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script>
  <script src="/articles/lib/velocity/velocity.min.js"></script>
  <script src="/articles/lib/velocity/velocity.ui.min.js"></script>

<script src="/articles/js/utils.js"></script>

<script src="/articles/js/motion.js"></script>


<script src="/articles/js/schemes/pisces.js"></script>


<script src="/articles/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'b78837f065395b7c4761',
      clientSecret: '58c95c03db39e7430738d663bfc8337a5c8e1e80',
      repo        : 'articles',
      owner       : 'Tubetrue01',
      admin       : ['Tubetrue01'],
      id          : '78e2bfe5c4c5058cefa9a3f5917fe82f',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
